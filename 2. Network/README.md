## 🗓 Timeline
| 주차 | 날짜 | 과목 | 주제 |
|--|--|--|--|
| 1주차 | 23.07.06 ~ 23.07.13 | 네트워크 | [네트워크 기초](./1.%20네트워크의%20기초)<br>[TCP/IP 4계층 모델](./2.%20TCP_IP%204계층%20모델)<br>[네트워크 기기](./3.%20네트워크%20기기)|
| 2주차 | 23.07.14 ~ 23.07.20 | 네트워크 | [IP 주소](./4.%20IP%20주소)<br>[HTTP](./5.%20HTTP)|
<br>
    
## 📝 Interview


<details>
<summary><b>summary</b></summary>
<div markdown="1">

- [질문을 적어주세요. 1](#질문을-적어주세요1)
- [질문을 적어주세요. 2](#질문을-적어주세요2)
- [질문을 적어주세요. 3](#질문을-적어주세요3)

</div>
</details>


<br>



#### 네트워크 병목현상에 대해 설명하고, 이를 해결할 수 있는 방안에 대해 말씀해주세요.
```
네트워크 병목현상이란 네트워크 상의 한 노드에서 처리할 수 있는 대역폭 이상의 데이터 양이 전송되거나 데이터가 특정 노드로 집중되어 네트워크의 전체적인 성능을 제한하는 경우를 말합니다. 

대역폭을 증가시키거나 로드밸런싱을 통해 병목현상을 해결할 수 있습니다. 대역폭을 증가시키면 처리할 수 있는 데이터 양이 증가되어 성능저하를 방지할 수 있고, 로드밸런싱을 통해 트래픽을 여러 장치로 균등하게 분산시키면 병목현상을 방지할 수 있습니다. 

```
<br>


#### 병목 현상이 무엇이며 해결 방법에 대해 설명하세요.

```
병목현상이란 전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해 제한을 받는 현상을 의미합니다.
병의 몸통보다 병의 목 부분 내부 지름이 좁아 물이 상대적으로 천천히 쏟아지는 것처럼, 서비스 이벤트 시 트래픽이 많아져 사용자가 웹 사이트로 들어가지 못하는 것을 말합니다.

이러한 병목 현상을 찾을 때 네트워크 토폴로지가 중요한 기준이 됩니다.
네트워크 토폴로지의 형태를 확인하고, 어떠한 경로로 이루어져 있는지 파악해야 병목 현상을 올바르게 해결 할 수 있습니다.
예를 들어 서비스 이용 시 대역폭을 크게 설정해도 지연 시간이 길게 발생한다면, 네트워크 토폴로지의 형태를 확인하여 게이트웨이로 이어지는 회선을 추가해서 병목 현상을 해결 할 수 있습니다.
```

<br>

#### 트래픽과 처리량의 차이점에 대해 설명하세요.

```
트래픽은 특정 시점에 링크 내에 흐르는 데이터의 양으로, 대표적인 예시로는 파일 다운로드 시 발생되는 데이터의 누적량이 있습니다.
처리량은 링크 내에서 성공적으로 전달된 데이터의 양으로, 즉 트래픽 처리량을 의미합니다.
트래픽은 흐르는 데이터의 양이며, 처리량은 처리되는 트래픽의 양입니다.
```
<br>

#### 네트워크 병목현상에 대해 설명하세요.
```
병목현상이란 시스템의 성능이나 용량이 하나의 구성요소로 인해 제한을 받는 현상을 말합니다.
이런 병목현상의 주요 원인으로는 네트워크 대역폭, 네트워크 토폴로지, 서버CPU와 메모리 사용량 그리고 비효율적인 네트워크 구성 등이 있습니다.
```
<br>

#### 트래픽과 처리량에 대해 설명하세요.
```
트래픽이란 특정시점에 링크내에 흐르는 데이이터의 양을 말합니다.
처리량이란 성공적으로 전달된 데이터의 양을 말하며 보통 얼마만큼의 트래픽을 처리했는지를 의미합니다.
처리량의 단위로는 bps를 사용하며 이는 초당 전송되는 비트 수를 말합니다.
처리량은 트래픽, 네트워크 장치간의 대역폭, 에러 그리고 장치의 하드웨어의 스팩에 영향을 받습니다.
```

---

#### OSI 7계층의 계층별 역할과 계층을 나눈 이유에 대해 설명해주세요.
```
OSI 7계층은 애플리케이션 계층, 표현계층, 세션계층, 전송계층, 네트워크계층, 데이터링크계층, 물리계층으로 구성되어있습니다. 

최상위 계층인 애플리케이션 계층에선 사용자에게 네트워크 자웡에 접근을 가능하도록 인터페이스를 제공하는 역할을 합니다. 사용자들이 실제로 실행하는 응용 프로그램등리 이 계층에 속하며 HTTP나 SMTP 등이 있습니다. 

4계층인 전송계층은 하위 계층에 신뢰할 수 있는 데이터 전송 서비스를 제공합니다. 

3계층인 네트워크 계층에선 실제 네트워크 간 라우팅을 진행합니다. 데이터를 패킷화하여 논리 주소를 사용하여 목적지까지 가장 빠르고 안전하게 전달하는 라우팅을 진행합니다.

최하위 계층인 물리 계층은 실제로 데이터가 전송되는 물리적인 매체를 의미합니다. 상위에서 받은 데이터를 전기적 신호인 0과 1의 형태로 변환하여 수신 매체로 전달합니다.

이와 같이 계층을 나눈 이유는 모듈화와 유연성을 위함입니다. 계층별로 역할을 분리하여 각 계층은 주어진 기능에만 집중할 수 있도록 모듈화하고, 각 계층이 다른 계층에게 영향을 받지 않도록 유연하게 설계하여 원하는대로 특정 계층을 변경하거나 업그레이드하기 용이합니다.
```
<br>

#### TCP 연결 및 연결해제 과정에 대해 설명하고 이 과정이 왜 필요한지에 대해 말씀해주세요.
```
OSI 7계층에서 전송계층에 해당하는 TCP는 신뢰성을 확보하기 위해 송신자와 수신자 사이 연결 과정과 연결 해제 과정을 진행합니다. 연결 과정을 3-way handshake, 연결 해제 과정을 4-way handshake 라고도 합니다. 

3-way handshake는 3단계 과정으로 이루어집니다. 첫 번째 단계에서 클라이언트가 서버로 자신의 고유번호를 담아 SYN 메시지를 보내 연결 요청을 합니다. 두 번째 단계에서 요청을 받은 서버는 수신을 확인했다는 ACK메시지와 연결 요청을 하는 SYN 메시지를 보냅니다. 이때 수신 승인 번호로 클라이언트의 고유번호에 1을 더한 값과 자신의 고유번호도 함께 담아 보냅니다. 세 번째 단계에서는 클라이언트가 서버의 SYN에 응답하며 서버 고유번호에 1을 더한 값을 담아 ACK 메시지를 보냅니다. 이를 통해 송수신자 사이 논리적 연결이 이루어지게 됩니다. 

4-way handshake는 4단계 과정으로 이루어져 있습니다. 논리적 연결 상태인 송수신자 사이에서 첫번째로 클라이언트가 FIN 메시지를 보내 해제 요청을 합니다. 두 번째 단계에서 서버는 이에 응답하는 ACK 메시지를 보내고 CLOSE_WAIT 상태로 들어가 남은 수신 데이터를 처리할 수 있도록 일정시간 대기합니다. 그런 후 서버는 다시 FIN 메시지를 보내 클라이언트 측에 해제 요청을 보냅니다. 마지막 단계로 클라이언트는 ACK 메시지를 보내 FIN 요청에 응답합니다. 이때 ACK 메시지를 받은 서버는 즉시 CLOSED 상태로 포트가 닫히게 되고 클라이어트는 일정시간 동안 대기하는 TIME_WAIT 상태 이후 CLOSED 상태로 포트를 닫게 됩니다. 
```
<br>

#### TCP와 UDP의 차이에 대해 설명해주세요.
```
두 프로토콜 모두 OSI 7계층에서 전송계층에 해당하는 프로토콜입니다. TCP는 연결 지향적으로 신뢰성을 보장하며 데이터 전송의 순서와 오류 복구를 지원하여 데이터의 순서를 보장합니다. 하지만, UDP는 비연결성이며 신뢰성을 보장하지 않아 데이터의 순서를 보장할 수 없고 데이터 손실이나 손상이 발생될 수 있습니다. UDP는 TCP보다 더 빠른 데이터 전송 속도를 가지고 있어 보통 TCP는 신뢰성이 중요한 응용 프로그램에, UDP는 신속한 전송이 중요한 응용 프로그램에 사용됩니다. 
```
<br>
#### OSI 7계층과 TCP/IP 4계층의 차이점에 대해 설명하세요.

```
OSI 계층은 애플리케이션 계층을 애플리케이션, 프레젠테이션, 세션 계층, 총 3개의 계층으로 나누고,
링크 계층을 데이터 링크 계층, 물리 계층으로 나눠서 설명하는 것이 다르며,
인터넷 계층을 네트워크 계층으로 부른다는 점이 다릅니다.
```

<br>

#### TCP 연결 성립 과정에 대해 설명하세요.

```
3-way handshake 과정으로,
1. SYN 단계: 클라이언트는 서버에 클라이언트의 ISN을 담아 SYN을 보냅니다. ISN은 새로운 TCP 연결의 첫 번째 패킷에 할당된 임의의 시퀀스 번호를 말하며 이는 장치마다 다를 수 있습니다.
2. SYN + ACK 단계: 서버는 클라이언트의 SYN를 수신하고 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN + 1을 보냅니다.
3. ACK 단계: 클라이언트는 서버의 ISN + 1한 값인 승인번호를 담아 ACK를 서버에 보냅니다.
```

<br>

#### TCP 연결 해제 과정에 대해 설명하세요.

```
4-way handshake 과정으로,
1. 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보냅니다. 그리고 FIN_WAIT_1 상태로 들어가고 서버의 응답을 기다립니다.
2. 서버는 클라이언트로 ACK라는 승인 세그먼트를 보냅니다. 그리고 CLOSE_WAIT 상태에 들어갑니다. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태에 들어갑니다.
3. 서버는 ACK를 보내고 일정 시간 이후에 클라이언트에 FIN이라는 세그먼트를 보냅니다.
4. 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED 상태가 됩니다. 이후 클라이언트는 어느 정도의 시간을 대기한 후 연결이 닫히고 클라이언트와 서버의 모든 자원의 연결이 해제됩니다.
```

<br>

#### 캡슐화와 비캡슐화에 대해 설명하세요.

```
캡슐화란 상위 계층의 헤더와 데이터를 하위 계층의 데이터 부분에 포함시키고 해당 계층의 헤더를 삽입하는 과정을 말합니다.
애플리케이션 계층의 데이터가 전송 계층으로 전달되면서 세그먼트 또는 데이터그램화되며 TCP(L4) 헤더가 붙여지게 됩니다.
인터넷 계층으로 가면서 IP(L3) 헤더가 붙여지게 되며 패킷화가 되고, 이후 링크 계층으로 전달되면서 프레임 헤더와 프레임 트레일러가 붙어 프레임화가 됩니다.

비캡슐화란 하위 계층에서 상위 계층으로 가며 각 계층의 헤더 부분을 제거하는 과정을 말합니다.
이렇게 캡슐화된 데이터를 받게 되면 링크 계층에서부터 타고 올라오면서 프레임화된 데이터는 다시 패킷화를 거치고
세그먼트, 데이터그램화를 거쳐 메시지화가 되는 비캡슐화 과정이 일어납니다.
그 이후 최종적으로 사용자에게 애플리케이션의 PDU인 메시지로 전달됩니다.
```

<br>

#### TCP/IP 4계층별 PDU에 대해 설명하세요.

```
네트워크의 어떤한 계층에서 계층으로 데이터가 전달될 때 한 덩어리의 단위를 PDU라고 합니다.
제어 관련 정보들이 포함된 헤더, 데이터를 의미하는 페이로드로 구성되어 있으며 계층마다 부르는 명칭이 다릅니다.
- 애플리케이션 계층: 메시지
- 전송 계층: 세그먼트(TCP), 데이터그램(UDP)
- 인터넷 계층: 패킷
- 링크 계층: 프레임(데이터 링크 계층), 비트(물리 계층)
```

#### TCP/IP 4계층 모델에 대해 설명해주세요.
```
TCP/IP 4계층은 네트워크에서 통신이 일어나는 과정을 4단계로 나눈 것을 말합니다.
제일 위부터 애플리케이션, 전송, 인터넷 그리고 링크 계층으로 구분됩니다.

애플리케이션 계층은 응용 프로그램이 사용되는 계층이며 웹 서비스나 이메일 등 서비스를 실질적으로 사용자들에게 제공하는 계층입니다.
애플리케이션 계층에서 사용되는 프로토콜로는 FTP, HTTP, SMTP, DNS 등이 있습니다.

전송 계층은 포트를 열어 응용 프로그램들이 통신할 수 있도록 합니다.
연결 지향 데이터 스트림 지원, 신뢰성, 흐름 제어 등의 기능을 제공할 수 있습니다.
대표적으로 TCP와 UDP 프로토콜이 동작합니다.

인터넷 계층은 각 호스트에게 IP주소를 부여해 데이터를 특정 목적지까지 전송하기 위해 사용되는 계층입니다.
단, 수신측에서 데이터를 제대로 받았는지는 보장하지 않는 비연결형적인 특징을 가지고 있습니다.
대표적으로 IP, ARP 등의 프로토콜이 동작합니다.

마지막으로 링크계층은 전선 등 하드웨어를 이용하여 실질적으로 데이터를 장치간에 전기신호로 변환하여 주고받는 역할을 하는 계층입니다.
링크 계층은 물리계층과 데이터 링크 계층으로 나누기도 합니다.
이때 링크 계층은 실제로 데이터를 주고받는 역할을 하며, 데이터 링크 계층은 이더넷 프레임을 통해 에러확인, 흐름제어 접근제어 등을 담당합니다.
```

<br>

#### 네트워크 계층구조를 구분한 이유에 대해 설명해주세요.
```
네트워크 계층구조를 구분한 이유는 통신과정을 단계별로 파악할 수 있기 때문입니다.
단계별로 통신과정을 파악할 수 있기 때문에 통신과정에서 문제가 발생할 경우 다른 단계의 장비 및 소프트웨어를 건드리지않고 문제가 발생한 단계를 찾아 해결할 수 있습니다.
```

<br>

#### TCP와 UDP의 차이에 대해 설명해주세요.
```
TCP와 UDP는 네트워크 계층 중 전송 계층에서 사용하는 프로토콜입니다.

TCP는 연결을 설정하여 전송되는 데이터의 신뢰성을 보장하며 네트워크에 연결된 컴퓨터에서 실행되는 프로그램 간에 패킷을 안정적으로 순서대로 에러 없이 교환할 수 있습니다.
하지만, 1:1 통신만 가능하며 UDP에 비해 상대적으로 느리다는 단점이 있습니다.

UDP는 연결을 설정하지 않기때문에 전송되는 데이터의 신뢰성을 보장하지 않습니다. 각각의 패킷은 다른 경로로 전송되며 패킷은 순서에 관계없이 목적지에 도달할 수 있습니다.
UDP는 1:1뿐만 아니라 1:N 그리고 N:N까지 통신할 수 있으며 TCP에 비해 상대적으로 빠른 속도를 보장합니다.
```

<br>

#### 로드밸런싱과 서버 부하를 처리하기 위한 2가지 방법에 대해 설명해주세요.
```
로드 밸런싱이란 서버가 처리해야 할 요청(Load)을 여러 대의 서버로 나누어(Balancing) 처리하는 것을 의미합니다.
한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 성능을 보일 수 있도록 하는 기능을 말합니다.
이런 로드밸런싱을 통한 서버 부하를 처리하는 방법으로는 스케일 업(Scale-up)과 스케일 아웃(Scale-out)이 있습니다.
```

<br>

#### 3 way handshake에 대해 설명해주세요.
```
TCP는 데이터 전송 전 신뢰성 확보를 위해 클라이언트와 서버를 연결하는 과정을 수행합니다.
이 과정은 3단계를 통해 진행하는데 이를 3-way-handshake라고 합니다.
진행 과정을 말씀드리면,
첫 째로, 클라이언트는 서버에 클라이언트의 ISN을 담아 SYN을 전송합니다. ISN은 새로운 TCP 연결의 첫 번째 패킷에 할당된 임의의 시퀀스 번호를 말합니다.
둘 째로, 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN + 1을 보냅니다.
마지막으로, 클라이언트는 서버의 ISN + 1한 값인 승인번호를 담아 ACK를 서버에 보냅니다.
이 과정 이후 서버와 클라이언트간의 신뢰성이 구축되고 데이터 전송이 시작됩니다. 
```

<br>

#### 4 way handshake에 대해 설명해주세요.
```
TCP가 연결했던 클라이언트와 서버간의 연결을 해제하기 위해 수행하는 연결해제 4단계의 과정을 말합니다.
먼저, 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 서버로 보냅니다. 그리고 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버의 응답을 기다립니다.
둘째로, 서버는 클라이언트로 ACK라는 승인 세그먼트를 보냅니다. 그리고 CLOSE_WAIT 상태에 들어갑니다. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태에 들어갑니다.
셋째로, 서버는 ACK를 보내고 일정 시간 이후에 클라이언트에 FIN이라는 세그먼트를 보냅니다.
마지막으로 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED 상태가 됩니다. 이후 클라이언트는 어느 정도의 시간을 대기한 후 연결이 닫히고 클라이언트와 서버의 모든 자원의 연결이 해제됩니다.
```

<br>

#### 4 way handshake에서 마지막에 TIME_WAIT을 하는 이유는?
```
두가지 이유가 있습니다.
첫째로, 지연 패킷이 발생할 경우를 대비하기 위함입니다.
패킷이 뒤늦게 도달하고 이를 처리하지 못한다면 데이터 무결성 문제가 발생할 수 있습니다.
둘쨰로, 두 장치가 연결이 닫혔는지 확인하기 위해서입니다.
만약, 두 장치가 완벽하게 닫히지 않은 상태로 다시 새로운 연결을 하려고 하게 된다면 오류가 발생할 수 있기 떄문입니다.
이런 이유로 TIME_WAIT이라는 잠시 기다릴 시간이 필요합니다.
```

<br>

#### 흐름제어와 혼잡제어에 대해 설명해주세요.
```
수신 측이 송신 측보다 데이터 처리 속도가 빠르면 문제가 없지만, 송신 측의 속도가 빠를 경우 문제가 생깁니다.
수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있으며, 만약 손실된다면 불필요한 추가 패킷 전송이 발생하게 됩니다.
흐름 제어는 위와 같이 송신 측과 수신 측의 TCP 버퍼 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위한 기법입니다.

데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못합니다.
이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 합니다.
이런 상황은 송신 측의 전송 속도를 적절히 조절하여 예방할 수 있는데, 이것을 혼잡 제어라고 합니다.
정리하자면, 흐름 제어는 송 수신 측 사이의 패킷 수를 제어하는 기능이라 할 수 있으며, 혼잡 제어는 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로우를 방지하는 기능입니다.
```

---

#### 로드밸런서가 어떤 역할을 하는 기기인지 설명해주세요.
```
로드밸런서란 서버에 가해지는 부하를 분산해주는 장치를 말합니다. 이를 통해 성능을 향상시키고 서비스의 가용성과 신뢰성을 높입니다. 
```
<br>

#### L4 로드밸런서와 L7 로드밸런서의 차이에 대해 설명해주세요.
```
L4 로드밸런서는 OSI 7계층 중 4계층인 전송계층에서 사용되는 장치를 말하며 L7 로드밸런서는 7계층인 애플리케이션 계층에서 사용되는 장치를 말합니다. 두 장치 모두 트래픽을 분산시켜 성능을 향상시키는 역할을 합니다. 

L4 로드 밸런서는 전송 계층에서 동작하며 IP 주소와 포트 번호에 기반하여 트래픽을 분산합니다. 반면, L7 로드 밸런서는 응용 계층에서 동작하며 페이로드의 내용을 분석하여 트래픽을 분산하기 때문에 HTTP 헤더, URL, 쿠키 등과 같은 상위 계층 프로토콜을 이해하고 처리할 수 있습니다. 

L7 로드 밸런서는 더 정교한 로드 밸런싱과 트래픽 관리 기능을 제공하여 웹 서버, 애플리케이션 서버 등에 더 특화된 로드 밸런싱을 수행합니다. L4 로드 밸런서는 단순히 IP 주소와 포트 번호를 기준으로 트래픽을 분산하는 반면, L7 로드 밸런서는 요청의 내용에 따라 트래픽을 더욱 지능적으로 분산하고 처리합니다.
```

#### L4 스위치와 L7 스위치의 차이에 대해 설명하세요.

```
L4 스위치는 전송 계층을 처리하는 기기로 스트리밍 관련 서비스에서는 사용할 수 없으며 메시지를 기반으로 인식하지 못하고 IP와 포트를 기반으로 트래픽을 분산합니다.
L7 로드밸런서는 IP, 포트 외에도 URL, HTTP 헤더, 쿠기 등을 기반으로 트래픽을 분산합니다.
클라우드 서비스(AWS 등)에서 L7 스위치를 이용한 로드밸런싱은 ALB(Application Load Balancer) 컴포넌트로 하며, L4 스위치를 이용한 로드밸런싱은 NLB(Network Load Balancer) 컴포넌트로 합니다.
```

<br>

#### 로드밸런서의 역할에 대해 설명하세요.

```
서비스를 안정적으로 운용하기 위해서는 에러 발생에도 서비스가 정상적으로 운용되어야 하기 때문에 2대 이상의 서버는 필수적입니다.
로드밸런서는 2대 이상의 서버를 기반으로 가상 IP를 제공하고 이를 기반으로 안정적인 서비스를 제공합니다.
```

#### L4 스위치와 L7스위치의 차이점에 대해 설명하세요.
```
L4 스위치는 전송계층을 처리하는 기기로 IP와 포트를 기반으로 트래픽을 분산하는 로드밸런서 역할을 수행합니다.
반면, L7 스위치는 IP와 포트외에도 페이로드(payload)까지 분석해 로드밸런싱을 합니다.
즉 패킷의 내용들(URL, 캐시, 쿠키)을 기반으로 트래픽을 분산할 수 있습니다.
즉, L7 스위치는 L4 보다 좀 더 세밀한 수준의 고급 로드 밸런싱과 트래픽 관리를 가능케 합니다.
```
<br>

#### 라우터란?
```
인터넷 계층을 처리하는 기기로 여러 개의 네트워크를 연결, 분할, 구분시켜주는 역할을 합니다.
또한, 다른 네트워크에 존재하는 장치끼리 서로 데이터를 주고받을 때 패킷 소모를 최소화하고 경로를 최적화하여 최소 경로로 패킷을 포워딩하는 라우팅을 하는 장비입니다.
```
<br>

---

#### ARP가 무엇이고 어떻게 동작하는지 설명하시오

```
동작과정은 우선, IP프로토콜이 ARP request 메시지 생성 요청을 보내면 
ARP가 해당 메시지를 생성하여 네트워크에 연결되어 있는 모든 호스트에게 브로드캐스팅 방식으로 전송합니다.
전송받은 수신자 중에 해당 IP주소에 해당하는 호스트가 ARP reply 메시지에 MAC 주소를 담아 유니캐스팅 방식으로 전송합니다.
그렇게 되면 송신자는 해당 IP에 대한 물리적 주소를 획득할 수 있습니다. 
```

#### IP란?
```
IP는 인터넷 프로토콜의 약자로 송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고 받는데 사용하는 통신규약이며, OSI 네트워크 계층에서 호스트의 주소 지정과 패킷 분할 및 조립 기능을 담당한다. 비신뢰성과 비연결성이 특징이다.
```
<br>

#### IP 주소란?
```
IP 주소는 너트워크 환경에서 컴퓨터간 통신하기 위해 각 컴퓨터에 부여된 네트워크 상의 주소를 말한다.
```
<br>

#### IPv6가 생겨난 이유는?
```
IP주소라는 개념이 처음 생겼을 당시에는 지금처럼 네트워킹이 가능한 장비의 종류가 다양하지 않았지만 기술이 발전하고 인터넷 사용자가 증가하면서 IPv4 주소의 수가 부족해졌다. 이를 해결하기 위해 주소 길이를 128비트로 늘려 사용가능한 주소의 개수를 2의 128제곱개 늘린 IPv6가 등장했다.
```
<br>

#### MAC 주소란?
```
MAC 주소는 데이터 링크 계층에서 통신을 위해 네트워크 인터페이스(NIC)에 할당된 고유 식별자이다. 이더넷 하드웨어 주소, 물리적 주소라고 불리며 다른 MAC 주소와 겹치지 않는다.
```
<br>

#### 통신과정에서 IP주소외에 MAC주소가 필요한 이유는?
```
통신과정에서 레이어의 최상단에서 최하단까지 캡슐화와 비캡슐화 과정이 이루어지면서 데이터가 송수신되는데 ip주소는 레이어3에서 사용되는 주소이고 mac주소는 레이어2인 데이터링크 계층에서 사용된다
```

<br>

#### NAT 사용이유와 장단점
```
```

<br>

#### DHCP란?
```
```

---

#### HTTP의 특징에 대해 설명해주세요.
```
HTTP는 무상태성, 비연결성의 특징을 가지고 있으며 서버-클라이언트 구조로 구성되어 있습니다. 
무상태성이란 각 HTTP 요청에 대한 상태를 기억하고 있지 않다는 것을 의미합니다. 
따라서 각 요청은 독립적이고 상태 정보를 사용하기 위해선 세션이나 쿠키를 통해 저장합니다.
비연결성은 요청을 주고받을 때만 연결을 유지하는 특징으로 전송이 끝나면 연결이 끊기는 특징을 가지고 있습니다.
```
<br>

#### 버전 별 HTTP에 대해 간략하게 설명해주세요.
```
HTTP/1.0은 매 요청마다 TCP 연결 및 해제 과정이 필요하기 때문에, 전송 패킷의 왕복시간인 RTT가 증가한다는 단점이 있습니다.
HTTP/1.1버전에선 keep-alive 옵션을 통해 기본값으로 한 번의 TCP연결에 여러 요청을 보낼 수 있게 되었습니다. 
하지만 HTTP/1.x 버전은 하나의 스트림에 한 요청에 대한 패킷만 왕복할 수 있었기 때문에 대기 큐의 앞 요청이 지연되면 
뒤의 요청까지 영향이 가 성능이 저하되는 HOL Blocking이 발생한다는 단점이 있습니다. 

이를 보완하기 위해 HTTP/2에서는 멀티플렉싱으로 여러 스트림을 통해 동시에 데이터를 송수신할 수 있습니다. 
멀티플렉싱 뿐만 아니라 클라이언트의 요청없이 서버에서 필요한 리소스를 전송해주는 서버 푸시를 통해 성능을 향상시킬 수 있습니다.
또한 1.X버전에서 무거웠던 헤더를 허프만 코딩 알고리즘을 통해 압축한 형식을 사용합니다.

HTTP/3에서는 이전 버전들과 달리 UDP를 기반으로 동작합니다. 이를 통해 TCP 연결 및 해제 과정이 없어져 초기 연결 시 지연시간이 감소합니다.
또한 UDP기반이기 때문에 패킷 손실률을 낮추기 위해 순방향 오류 수정 메커니즘을 사용합니다. 
```

#### HTTP는?
```
텍스트 기반의 통신 규약으로 서버-클라이언트 구조를 따르며 인터넷 상에서 데이터를 주고받는데 사용하는 프로토콜입니다.
```
<br>

#### HTTP의 상태코드가 무엇인지 그리고 대표적인 상태 코드에 대해 설명해주세요.
```
클라이언트가 보낸 요청의 처리상태를 응답에서 숫자로 표현하여 알려주는 기능입니다. 보통 100~500 사이의 숫자로 표현됩니다.
100번대는 요청을 수신하여 처리중임을 의미합니다.
200번대는 요청을 정상 처리했음을 의미합니다.
300번대는 요청을 완료하려면 추가행동이 필요함을 의미합니다.
400번대는 클라이언트쪽의 오류로 잘못된 문법등으로 서버가 요청을 처리할 수 없는 상태임을 의미합니다.
500번대는 서버 오류로 서버가 정상요청을 처리하지 못했음을 의미합니다.
```
<br>

#### HTTP 의 특징은?
```
HTTP는 TCP/IP 위에서 동작하는 프로토콜입니다. 서버와 클라이언트의 연결을 유지하지 않는 비연결성 프로토콜이며 서버가 클라이언트의 상태를 유지하지 않는 무상태 프로토콜입니다. 또한 클라이언트와 서버의 요청과 응답 구조로 HTTP 메시지를 이용해 통신하는 특징을 가지고 있습니다.
```
<br>

#### HTTP의 버전별 차이에 대해 설명해주세요.
```
```

<br>

#### HTTP 메서드에 대해 아는대로 설명해보시오.
```
HTTP 메서드는 클라이언트가 서버에게 사용자의 요청의 목적이나 종류를 알리는 수단입니다. 대표적으로 GET, POST, PUT, PATCH, DELETE가 있습니다. GET 메서드는 리소스 조회, POST 메서드는 요청 리소스 처리 및 리소스 등록, PUT은 리소스 대체, PATCH는 리소스 수정, DELETE는 리소스 삭제시 사용합니다.
```

<br>

#### HTTPS와 HTTP의 차이점은 무엇인가요
```
HTTP와 HTTPS의 차이점은 데이터의 암호화 입니다. HTTP는 전송 데이터가 암호화되지 않는 단점을 가지고있습니다. 이를 보완하기 위해 통신 보안을 제공하는 SSL을 사용해 클라이언트와 서버가 전송 데이터를 암호화하여 안전하게 사용할 수 있도록 만들어진 프로토콜 입니다.
```

<br>

#### HTTP와 Socket 통신방식의 차이점에 대해 설명해주세요.
```
HTTP는 기본적으로 비연결성의 특징을 가지고 있습니다. 클라이언트의 요청이 있을때에만 서버가 응답해서 데이터를 전송하고 곧바로 연결을 끊는 방식입니다. 즉, 클라이언트가 요청하고 서버가 응답하는 단방향 통신입니다.
이에 반해, socket 통신은 클라이언트와 서버가 특정 port를 통해 연결을 성립하고 있어 실시간으로 양방향 통신을 하는 통신 방식입니다. 클라이언트가 서버에게 요청을 보내는 http 통신과 달리 server도 client에게 요청을 보낼 수 있습니다. 따라서, 스트리밍이나 실시간 채팅등에 자주 사용됩니다.
```

<br>

#### SSL이란?
```
SSL이란 서버와 클라이언트 사이에 암호화된 연결을 만들어 안전한 데이터 교환이 가능하도록 하는 컴퓨터 네트워크에 통신보안을 제공하기 위해 설계된 프로토콜입니다. SSL은 보안과 성능상의 이유로 대칭키와 공개키 두가지 암호화 기법을 혼용해서 사용하며 SSL Handshake라는 과정을 통해 데이터 전송 전 보안 세션을 생성합니다.
```

<br>

#### SSL의 연결과정인 SSL Handshake에 대해 설명해주세요.
```
SSL Handshake 과정은 여덟단계를 통해 연결과정을 진행합니다.

먼저,

첫 번째로, ClinetHello 단계에서 사용자가 서버에 접속을 요청하며 Cipher Suite를 전달합니다.
두번째로, ServerHello 단계에서 서버는 클라이언트에게 전달받은 Cipher Suite중에서 서버가 사용가능한 암호화방식을 선택해 사용자에게 전달합니다.
세번째로, Certificate 단계에서 서버는 자신의 인증서를 사용자에게 전달합니다.
네번째로 ServerHelloDone 단계에서 사용자는 브라우저에 내장된 CA의 공개키를 이용해 사이트 인증서를 복호화하면서 인증서가 유효한지 검증하고 사이트의 공개키를 가져옵니다.
다섯번째로, ClientKeyExchange 단계에서 사용자는 자신이 전달할 데이터를 암호화할 대칭키를 만들고 그 대칭키를 사이트 공개키로 암호화합니다.
여섯번째로 사용자의 Finished 단계에서 암호화한 사용자의 대칭키를 서버에 전달합니다.
일곱번째로 서버 Finished 단계에서 사이트는 자신의 개인키를 사용하여 사용자 대칭키를 복호화하여 사용자의 대칭키를 얻습니다.
마지막으로 이렇게 얻은 대칭키를 활용하여 데이터를 암호화 및 복호화하며 통신합니다.
```

<br>