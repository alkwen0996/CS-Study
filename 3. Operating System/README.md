## 🗓 Timeline
| 주차 | 날짜 | 과목 | 주제 |
|--|--|--|--|
| 1주차 | 23.07.06 ~ 23.07.13 | 운영체제 | [운영체제와 컴퓨터](./1.%20운영체제와%20컴퓨터)<br>[메모리](./2.%20메모리)<br>[CPU 스케줄링 알고리즘](./4.%20CPU%20스케줄링%20알고리즘)<br>|
<br>
    
## 📝 Interview


<details>
<summary><b>summary</b></summary>
<div markdown="1">

- [질문을 적어주세요. 1](#질문을-적어주세요1)
- [질문을 적어주세요. 2](#질문을-적어주세요2)
- [질문을 적어주세요. 3](#질문을-적어주세요3)

</div>
</details>


<br>


### 커널과 시스템콜에 대해 설명해주세요.

```
커널은 운영체제의 핵심 프로그램으로, 시스템의 모든 것을 완전히 제어하는 역할을 합니다. 커널은 시스템콜 인터페이스를 제공하며 하드웨어와 응용 프로그램 간의 중재자 역할을 합니다.

시스템콜은 응용 프로그램이 커널의 기능을 사용하여 운영체제의 서비스를 사용할 수 있도록 하는 인터페이스입니다. 응용 프로그램은 시스템콜을 사용하여 커널에 특정 작업을 요청하면 유저모드에서 커널모드로 변환되어 해당 작업을 수행합니다.

```

<br>

### 운영체제의 역할에 대해 설명하세요.

```
1. CPU 스케줄링과 프로세스 관리: CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 지원 할당 및 반환을 관리합니다.
2. 메모리 관리: 한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리합니다.
3. 디스크 파일 관리: 디스크 파일을 어떠한 방법으로 보관할지 관리합니다.
4. I/O 디바이스 관리: I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리합니다.

```

<br>

### 시스템콜에 대해 설명하세요.

```
시스템 콜이란 `운영체제가 커널에 접근하기 위한 인터페이스`로, 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 씁니다.
유저 프로그램이 I/O 요청으로 트랩(trap)을 발동하면, 올바른 I/O 요청인지 확인한 후 유저 모드가 시스템콜을 통해 커널 모드로 변환되어 실행됩니다.
예를 들어 fs.readFile()이 발동하면, 커널모드로 들어가 파일을 읽고 유저 모드로 돌아가 그 뒤에 있는 유저 프로그램의 로직을 수행합니다.
이 과정을 통해 컴퓨터 자우너에 대한 직접 접근을 차단할 수 있고 프로그램을 다른 프로그램으로부터 보호할 수 있습니다.

```

<br>

### 인터럽트에 대해 설명하세요.

```
어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것을 말합니다.
키보드, 마우스 등 IO 디바이스로 인한 인터럽트, 0으로 숫자를 나누는 산술 연산에서의 인터럽트, 프로세스 오류 등으로 발생합니다.
인터럽트가 발생되면 인터럽트 핸들러 함수가 모여 있는 인터럽트 벡터로 가서 인터럽트 핸들러 함수가 실행됩니다.
인터럽트 간에는 우선순위에 따라 실행되며, 인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트 두 가지로 나뉩니다.

```

<br>

### 시스템콜이란?

```
시스템 콜은 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스입니다.
사용자들이 사용하는 유저모드인 응용프로그램에서는 커널에 접근할 수 있는 권한이 없기 때문에 제공하는 운영체제의 커널이 제공하는 서비스들을 이용할 수 없습니다.
따라서, 응용프로그램들이 운영체제가 제공하는 서비스를 이용하기 위해서는 먼저 커널에 접근할 수 있는 권한을 얻어야 합니다.
시스템콜은 커널 영역의 기능을 유저모드인 응용프로그램에서 사용 가능하게 해주는 역할을 합니다.

```

<br>

### 유저모드와 커널모드

```
CPU는 사용자 애플리케이션 (User application)이 시스템을 손상시키는 것을 방지하기 위해 유저모드와 커널모드, 2가지 모드를 제공합니다.
CPU에 있는 Mode bit로 모드를 구분하여 0은 커널모드(kernel mode), 1은 사용자모드 (user mode)로 나뉘어서 구동하게 됩니다.

사용자 모드에서는 사용자 애플리케이션 코드가 실행됩니다.
사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어(디스크, I/O 등)에 접근할 수 없습니다.
접근을 위해서는 '시스템 콜(System Call)'을 사용해야 합니다.

커널 모드는 모든 컴퓨터 자원에 접근할 수 있는 모드입니다.
시스템 콜을 통해 사용자 모드에서 커널모드로 전환이 되면 운영체제는 하드웨어를 제어하는 명령어를 실행합니다.
만약, 하드웨어를 제어하는 명령어는 사용자 모드에서 실행되면 exception이 발생합니다.

```

<br>

### 커널에 대해 설명해주세요.

```
커널은 운영체제의 핵심 부분이자 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일시스템, I/O 디바이스, I/O 요청관리 등 운영체제의 중추적인 역할을 수행합니다.

```

<br>

### 캐시에 대해 설명해주세요.

```
캐시는 데이터의 빠른 접근을 위해 사용되는 임시 저장소로, 빠른 장치와 느린 장치 사이의 속도 차이에서 발생하는 병목 현상을 줄이기 위해 설계된 메모리입니다.주로 CPU와 메인메모리 사이에 위치하며, CPU가 데이터를 요청할 때 먼저 캐시에서 찾아보고 캐시에 데이터가 있는 경우 빠르게 반환합니다.

```

<br>

### 지역성의 원리에 대해 설명해주세요.

```
캐시의 적중률을 높일 수 있는 원리로 데이터에 접근하는 패턴을 설명한 원리입니다. 시간적 지역성과 공간적 지역성으로 나뉩니다. 시간적 지역성은 최근 사용한 데이터에 다시 접근하려는 특성을 말하고, 공간적 지역성은 최근 접근한 데이터의 주변 공간에 접근하려는 특성을 말합니다. 캐시는 지역성의 원리를 이용하여 자주 사용되는 데이터를 빠르게 접근하여 적중률을 높일 수 있습니다.

```

<br>

### 가상메모리에 대해 설명해주세요.

```
가상 메모리는 메모리 관리 기술로, 실제 물리적인 메모리보다 큰 용량의 가상 주소 공간을 프로세스에 제공하는 방법입니다. 가상 메모리는 각 프로세스에게 독립적으로 할당되며, 실제 필요한 데이터만 물리적 메모리에 올리고, 그렇지 않은 데이터는 보조기억장치에 보관하는 방식으로 동작합니다.

각 프로세스가 가상 메모리의 가상 주소에 접근 하면 메모리관리장치(MMU)가 실제 주소로 변환하여 물리적 공간에 접근할 수 있도록 합니다.

```

### 메모리 계층에 대해 설명하세요.

```
- 레지스터: CPU 안에 있는 작은 메모리로 휘발성이며 속도가 가장 빠르고 기억 용량이 가장 적습니다.
- 캐시: L1, L2 캐시를 지칭하며, 휘발성이며 속도가 빠르고 기억 용량이 적습니다.
- 주기억장치: RAM으로, 휘발성이며 속도와 기억 용량은 보통입니다. 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요 시마다 CPU에 빠르게 전달하는 역할을 합니다.
- 보조기억장치: HDD, SSD를 말하며 비휘발성으로 속도는 낮으나 기억 용량이 많습니다.

```

<br>

### 캐시란 무엇인가요?

```
데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말합니다.
이를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고, 무언가를 다시 계산하는 시간을 절약할 수 있습니다.
실제로 메모리와 CPU 사이의 속도 차이가 너무 크기 때문에 그 중간에 레지스터 계층을 둬서 속도 차이를 해결합니다.
이렇게 속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층을 캐싱 계층이라고 합니다.
캐시 메모리와 보조기억장치 사이에 있는 주기억장치를 보조기억장치의 캐싱 계층이라고 할 수 있습니다.

```

<br>

### 웹브라우저의 캐시에 대해 설명하세요.

```
사용자의 커스텀한 정보나 인증 모듈 관련 사항들을 웹 브라우저에 저장해서 추후 서버에 요청할 때 자신을 나타내는 아이덴티티나 중복 요청 방지를 위해 쓰입니다.

💡 쿠키
만료 기한이 있는 key-value 저장소입니다.
same site 옵션을 strict로 설정하지 않았을 경우 다른 도메인에서 요청했을 때 자동 전송되며, 4KB까지 데이터를 저장할 수 있고 만료기한을 정할 수 있습니다.
쿠키를 설정할 때는 document.cookie로 쿠키를 볼 수 없게 httponly 옵션을 거는 것이 중요하며, 클라이언트 또는 서버에서 만료기한 등을 정할 수 있는데 보통 서버에서 만료기한을 정합니다.

💡 로컬 스토리지
만료기한이 없는 key-value 저장소로, 10MB까지 저장할 수 있으며 웹 브라우저를 닫아도 유지되고 도메인 단위로 저장/생성됩니다.
HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없으며, 클라이언트에서만 수정 가능합니다.

💡 세션 스토리지
만료기한이 없는 key-value 저장소로, 탭 단위로 세션 스토리지를 생성하며, 탭을 닫을 때 해당 데이터가 삭제됩니다.
5MB까지 저장이 가능하면 HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없으며, 클라이언트에서만 수정 가능합니다.

```

<br>

### 페이지 폴트와 스와핑 과정에 대해 설명하세요.

```
1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생해서 운영체제에 알립니다.
2. 운영체제는 CPU의 동작을 잠시 멈춥니다.
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 프레임이 있는지 찾습니다. 물리 메모리에도 없다면 스와핑이 발동됩니다.
4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화합니다.
5. 중단되었던 CPU를 다시 시작합니다.

```

### 메모리의 종류에 대해 설명하고, 종류가 여러가지인 이유에 대해 설명해주세요.

```
CPU에 가까운 순서대로 레지스터, 캐시, 주기억장치, 보조기억장치가 있습니다.
물리적 메모리의 종류가 많은 이유는, 접근 속도에 따른 차이를 두기 위해서입니다. (레지스터 > 캐시 > 주기억장치 > 보조기억장치)

```

<br>

### 가상메모리란?

```
가상 메모리는 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법입니다.
가상메모리가 없다면 실행되는 코드의 전부를 적재해야 하므로 메모리 용량보다 큰 프로그램을 실행할 수 없습니다.
가상메모리를 사용하면 동시에 많은 프로그램을 실행할 수 있고, 응답시간을 유지하면서 CPU 이용률과 처리율을 높일 수 있습니다.

```

<br>

### OS가 메모리 관리를 해야하는 이유에 대해 설명해주시고, 메모리 관리를 위해 어떤 전략을 사용하는지 설명해주세요.

```
운영체제가 메모리를 관리해야 하는 이유에 대해 답변하자면
우선, 각각의 프로세스는 독립된 메모리 공간을 갖습니다. 따라서 각 프로세스는 다른 프로세스의 메모리 공간에 접근할 수 없습니다.
'운영체제'만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 영향을 받지 않습니다. 따라서 운영체제만이 메모리를 관리할 수 있기 때문에 적절한 관리가 필요합니다.
운영체제의 메모리 관리 전략으로는 가상메모리를 이용한 Swapping, 페이징 및 세그멘테이션 전략, 고정 길이 할당 / 가변 길이 할당, 압축 등의 방식이 있습니다.

```

<br>

### 페이징과 세그멘테이션에 대해 설명해주세요.

```
페이징 기법이란 가상메모리를 같은 크기의 블록의 페이지로 분리하고 메모리를 페이지와 같은 크기의 프레임으로 분리해서 메인 메모리에 불연속으로 저장하는 방식입니다.
페이지와 프레임을 대응시키기 위해 page mapping과정이 필요해서 paging table을 만듭니다.
페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다.
그러나 페이지 단위를 작게하면 외부 단편화 문제를 해결할 수 있지만 그 대신 page mapping과정이 많아져 효율이 떨어지게 된다.
또한, 페이지 단위에 따라 내부단편화의 문제도 존재합니다.

세그멘테이션이란 프로세스를 가변적인 크기의 세그먼트로 분리하고 메모리에 적재합니다.
주로 논리적인 블록단위 세그먼트로 Code, Data, Stack & Heap으로 분리할 수 있습니다.
세그멘테이션 역시 '외부 단편화'가 발생할 수 있습니다.

```

<br>

### 내부, 외부단편화에 대해 설명해주세요.

```
내부 단편화는 메모리를 나눈 크기보다 프로그램이 작아서 사용하지 못하는 공간이 많이 발생하는 현상을 말합니다.
외부 단편화는 메모리를 나눈 크기보다 프로그램이 커서 사용하지 못하는 공간이 많을때 발생하는 현상입니다.

```

<br>

### 쓰레싱에대해 설명해주세요.

```
페이지 부재율이 높은 상태를 의미합니다.
페이지 부재가 발생하면, 페이지 교체 혹은 페이지 로드가 일어납니다.
다양한 프로세스가 메모리에 올라오면서 메모리의 유효 사용 공간은 줄어들고, CPU의 가동 시간이 올라가면서 자원을 최대한 사용하게 됩니다.
그러나 메모리에 프로세스가 너무 많아지면, 프로세스당 물리 메모리를 사용할 수 있는 프레임의 개수가 줄어들고, 페이지가 물리 메모리에 적게 올라온 프로세스는 명령이 진행될 때 마다 Page Fault가 일어나 페이지 교체가 일어나게 됩니다.
이 경우엔 CPU 사용률이 줄어들게 됩니다.
페이지를 교체하는 과정에서는 CPU를 사용하지 않고, 페이지 교체만을 계속해서 실행하면, 운영체제는 CPU가 놀고 있으므로 더 많은 프로세스를 메모리에 올리려고 하며 악순환이 일어나게 됩니다.
이러한 현상을 Thrashing(쓰레싱)이라고 합니다.

이를 해소 하기 위해서 Working Set 알고리즘과 Page Fault Frequency 알고리즘을 사용합니다.
Working Set이란 대부분의 프로세스가 특정 페이지만 집중적으로 참조하는 특성을 이용, 일정 시간 동안 참조되는 페이지 개수를 파악하고, 그 페이지 수만큼 여분 프레임이 확보되면 그 때 페이지를 메모리에 올리는 알고리즘 입니다.
Page Fault Frequency는 Page Fault 퍼센트의 상한과 하한을 둡니다.
상한을 넘으면 페이지에게 지급하는 프레임 개수를 늘리고, 하한을 넘으면 지급 프레임 개수를 줄입니다.
또 CPU 사용률과 메모리 적재량을 함께 체크해야 쓰레싱 유무를 확인할 수 있게 됩니다.

```

<br>

### 캐시(cache) 메모리를 왜 사용하는지, CPU의 적중률을 높이기 위해 어떤 원리를 사용하는지에 대해 설명해주세요.

```
CPU와 메모리 사이의 속도 차이를 완화하기 위해 사용합니다.
메모리의 데이터를 미리 가져와 저장해두는 임시 장소로, 캐시의 크기는 메인 메모리보다 작기 때문에 앞으로 사용될 것으로 예상하는 데이터를 미리 저장하는 것이 중요한 포인트입니다.

따라서 이 캐시에 있는 데이터를 사용하는 것을 '적중'이라고 하고, 이러한 적중률을 높이기 위해서 지역성의 원리를 사용합니다.
지역성의 원리는 시간 지역성과 공간 지역성으로 나눌 수 있습니다.
시간 지역성은 최근 참조된 주소의 데이터에 다시 접근하려는 특성입니다.
공간 지역성은 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성을 말합니다.

```

<br>

### 메모리 할당 중, 연속(Contiguous) 방식과 불연속(Non-Contiguous) 방식에 대해 설명해주세요.

```
연속 할당 방식은, 프로세스 이미지가 분리되지 않은 온전한 프로세스를 메인 메모리에 적재하는 방식입니다. 연속 할당 방식에는 크게 2가지가 있으며 '고정 길이 할당'과 '가변 길이 할당'이 있습니다.
고정 길이 할당은 메모리를 고정된 길이로 파트를 분리하고, 프로세스를 해당 파트에 삽입합니다. 고정된 길이의 파트 내에 프로세스가 들어가므로, 여백이 생길 수 있는데 이것을 '내부 단편화'라고 합니다.
가변 길이 할당은 메모리를 프로세스의 길이에 알맞게 파트를 분리하고, 해당 프로세스를 적재합니다. 가변된 길이이므로 내부 단편화는 발생하지 않지만, 가변적인 길이 할당에 의해 일부분이 남으므로 '외부 단편화'가 발생합니다.

불연속 할당 방식은, 프로세스가 연속된 이미지가 아닌 분리된 이미지로 구성되어 메인 메모리에 적재하는 방식입니다. '페이징'과 '세그멘테이션' 방식이 있습니다.
페이징은 프로세스를 동일한 크기의 페이지로 분리, 메모리는 해당 페이지와 동일한 크기의 프레임으로 분리해서 메인 메모리에 불연속적으로 저장하는 방식입니다. 단, 내부단편화가 발생할 수 있습니다.
세그멘테이션은 프로세스를 가변적인 크기의 세그먼트로 분리하고 메모리에 적재합니다. 주로 논리적인 블록단위 세그먼트로 Code, Data, Stack & Heap으로 분리할 수 있습니다. 세그멘테이션 역시 '외부 단편화'가 발생할 수 있습니다.

```

<br>

### CPU 스케줄링 알고리즘 중 비선점형과 선점형의 차이에 대해 설명해주세요.

```
비선점형 스케줄링 알고리즘은 한 번 CPU를 할당받은 프로세스가 CPU를 반납하기 전까지 계속 실행되며 다른 프로세스가 CPU를 강제로 빼앗을 수 없습니다. 반면, 선점형 스케줄링 알고리즘은 현재 실행 중인 프로세스가 다른 프로세스에 의해 중단될 수 있습니다. 우선순위나 시간 할당량 등의 기준에 따라 프로세스 간 CPU를 빼앗을 수 있습니다.

```

<br>

### 라운드 로빈 알고리즘에 대해 설명해주세요.

```
라운드 로빈 알고리즘은 선점형 CPU 스케줄링 알고리즘 중 하나입니다. 동일한 할당 시간을 갖고 있는 여러 프로세스들에게 CPU를 차례로 할당하는 방식입니다. 프로세스들이 공정하게 CPU를 사용할 수 있도록 하며, 각 프로세스는 할당 시간 동안 실행되고 할당 시간이 경과하면 다음 프로세스에게 CPU를 양도합니다. 이 과정은 계속해서 반복됩니다. 이 알고리즘은 로드밸런서에서 트래픽 분산 알고리즘으로도 쓰입니다.

```

### CPU 스케줄링의 목적에 대해 설명하세요.

```
CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 프로세스에서 해야 하는 일을 스레드 단위로 CPU에 할당합니다.
프로그램이 실행될 때는 CPU 스케줄링 알고리즘이 어떤 프로그램에 CPU 소유권을 줄 것인지 결정합니다.
CPU 이용률은 높게, 주어진 시간에 많은 일을 하게,
준비 큐(ready queue)에 있는 프로세스는 적게, 응답 시간을 짧게 설정한느 것을 목표로 합니다.

```

<br>

### 비선점형과 선점형의 차이에 대해 설명하세요.

```
비선점형은 프로세스가 스스로 CPU 소유권을 포기하는 방식으로, 강제로 프로세스를 중지하지 않습니다. 따라서 컨텍스트 스위칭으로 인한 부하가 적습니다.
선점형은 현대 운영체제가 쓰는 방식으로 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식을 말합니다.

```

<br>

### RR 스케줄링에 대해 설명하세요.

```
현대 컴퓨터가 쓰는 스케줄링인 우선순위 스케줄링(priority scheduling)의 일종으로,
각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘입니다.

q만큼의 할당 시간이 부여되고 N개의 프로세스가 운영된다고 하면 (N - 1) * q 시간이 지나면 자기 차례가 오게 됩니다.
할당 시간이 너무 크면 FCFS가 되고, 짧으면 컨텐스트 스위칭이 잦아져서 오버헤드가 발생하여 비용이 커집니다.
일반적으로 전체 작업 시간은 길어지지만 평균 응답 시간은 짧아진다는 특징이 있습니다.

로드밸런서에서 트래픽 분산 알고리즘으로도 쓰입니다.

```

### CPU 스케줄링과 알고리즘에 대해 설명해주세요.

```
CPU는 한번에 하나의 프로세스만 실행가능합니다.
따라서, CPU 스케줄링은 언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업입니다.
이 알고리즘은 CPU 이용률은 높게, 주어진 시간에 많은 일을 하게, 준비 큐에 있는 프로세스는 적게, 응답시간은 짧게 설정하는 것을 목표로 합니다.

CPU 스케쥴링은 크게 비선점형 방식과 선점형 방식으로 나눌 수 있습니다.
비선점형 방식은 어떤 프로세스가 CPU를 점유하고 있다면 이를 뺏을 수 없는 방식으로 강제로 프로세스를 중지하지 않습니다.
따라서, 컨텍스트 스위칭으로 인한 부하가 상대적으로 적습니다. 해당하는 알고리즘으로는 FCFS, SJF, 우선순위가 있습니다.

선점형 방식은 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에 CPU의 소유권을 할당하는 방식입니다.
처리 시간이 매우 긴 프로세스의 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능하지만 잦은 컨텍스트 스위칭으로 인해 오버헤드(Overhead)가 커질 수 있다.
해당하는 알고리즘으로는 라운드로빈, SRF, 다단계 큐가 있습니다.

```

<br>
