## 📝 Interview

#### 메모리의 종류에 대해 설명하고, 종류가 여러가지인 이유에 대해 설명해주세요.
```
CPU에 가까운 순서대로 레지스터, 캐시, 주기억장치, 보조기억장치가 있습니다.
물리적 메모리의 종류가 많은 이유는, 접근 속도에 따른 차이를 두기 위해서입니다. (레지스터 > 캐시 > 주기억장치 > 보조기억장치)
```
<br>

#### 가상메모리란? 
``` 
가상 메모리는 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법입니다.
가상메모리가 없다면 실행되는 코드의 전부를 적재해야 하므로 메모리 용량보다 큰 프로그램을 실행할 수 없습니다.
가상메모리를 사용하면 동시에 많은 프로그램을 실행할 수 있고, 응답시간을 유지하면서 CPU 이용률과 처리율을 높일 수 있습니다.
```
<br>

#### OS가 메모리 관리를 해야하는 이유에 대해 설명해주시고, 메모리 관리를 위해 어떤 전략을 사용하는지 설명해주세요.
```
운영체제가 메모리를 관리해야 하는 이유에 대해 답변하자면
우선, 각각의 프로세스는 독립된 메모리 공간을 갖습니다. 따라서 각 프로세스는 다른 프로세스의 메모리 공간에 접근할 수 없습니다.
'운영체제'만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 영향을 받지 않습니다. 따라서 운영체제만이 메모리를 관리할 수 있기 때문에 적절한 관리가 필요합니다.
운영체제의 메모리 관리 전략으로는 가상메모리를 이용한 Swapping, 페이징 및 세그멘테이션 전략, 고정 길이 할당 / 가변 길이 할당, 압축 등의 방식이 있습니다.
```
<br>

#### 페이징과 세그멘테이션에 대해 설명해주세요.
```
페이징 기법이란 가상메모리를 같은 크기의 블록의 페이지로 분리하고 메모리를 페이지와 같은 크기의 프레임으로 분리해서 메인 메모리에 불연속으로 저장하는 방식입니다.
페이지와 프레임을 대응시키기 위해 page mapping과정이 필요해서 paging table을 만듭니다.
페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다.
그러나 페이지 단위를 작게하면 외부 단편화 문제를 해결할 수 있지만 그 대신 page mapping과정이 많아져 효율이 떨어지게 된다.
또한, 페이지 단위에 따라 내부단편화의 문제도 존재합니다.

세그멘테이션이란 프로세스를 가변적인 크기의 세그먼트로 분리하고 메모리에 적재합니다.
주로 논리적인 블록단위 세그먼트로 Code, Data, Stack & Heap으로 분리할 수 있습니다.
세그멘테이션 역시 '외부 단편화'가 발생할 수 있습니다.
```
<br>

#### 내부, 외부단편화에 대해 설명해주세요.
```
내부 단편화는 메모리를 나눈 크기보다 프로그램이 작아서 사용하지 못하는 공간이 많이 발생하는 현상을 말합니다.
외부 단편화는 메모리를 나눈 크기보다 프로그램이 커서 사용하지 못하는 공간이 많을때 발생하는 현상입니다.
```
<br>

#### 쓰레싱에대해 설명해주세요.
```
페이지 부재율이 높은 상태를 의미합니다. 
페이지 부재가 발생하면, 페이지 교체 혹은 페이지 로드가 일어납니다.
다양한 프로세스가 메모리에 올라오면서 메모리의 유효 사용 공간은 줄어들고, CPU의 가동 시간이 올라가면서 자원을 최대한 사용하게 됩니다.
그러나 메모리에 프로세스가 너무 많아지면, 프로세스당 물리 메모리를 사용할 수 있는 프레임의 개수가 줄어들고, 페이지가 물리 메모리에 적게 올라온 프로세스는 명령이 진행될 때 마다 Page Fault가 일어나 페이지 교체가 일어나게 됩니다.
이 경우엔 CPU 사용률이 줄어들게 됩니다. 
페이지를 교체하는 과정에서는 CPU를 사용하지 않고, 페이지 교체만을 계속해서 실행하면, 운영체제는 CPU가 놀고 있으므로 더 많은 프로세스를 메모리에 올리려고 하며 악순환이 일어나게 됩니다.
이러한 현상을 Thrashing(쓰레싱)이라고 합니다.

 
이를 해소 하기 위해서 Working Set 알고리즘과 Page Fault Frequency 알고리즘을 사용합니다.
Working Set이란 대부분의 프로세스가 특정 페이지만 집중적으로 참조하는 특성을 이용, 일정 시간 동안 참조되는 페이지 개수를 파악하고, 그 페이지 수만큼 여분 프레임이 확보되면 그 때 페이지를 메모리에 올리는 알고리즘 입니다.
Page Fault Frequency는 Page Fault 퍼센트의 상한과 하한을 둡니다.
상한을 넘으면 페이지에게 지급하는 프레임 개수를 늘리고, 하한을 넘으면 지급 프레임 개수를 줄입니다.
또 CPU 사용률과 메모리 적재량을 함께 체크해야 쓰레싱 유무를 확인할 수 있게 됩니다.
```
<br>

#### 캐시(cache) 메모리를 왜 사용하는지, CPU의 적중률을 높이기 위해 어떤 원리를 사용하는지에 대해 설명해주세요.
```
CPU와 메모리 사이의 속도 차이를 완화하기 위해 사용합니다. 
메모리의 데이터를 미리 가져와 저장해두는 임시 장소로, 캐시의 크기는 메인 메모리보다 작기 때문에 앞으로 사용될 것으로 예상하는 데이터를 미리 저장하는 것이 중요한 포인트입니다.
 
따라서 이 캐시에 있는 데이터를 사용하는 것을 '적중'이라고 하고, 이러한 적중률을 높이기 위해서 지역성의 원리를 사용합니다.
지역성의 원리는 시간 지역성과 공간 지역성으로 나눌 수 있습니다.
시간 지역성은 최근 참조된 주소의 데이터에 다시 접근하려는 특성입니다.
공간 지역성은 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성을 말합니다.
```
<br>

#### 메모리 할당 중, 연속(Contiguous) 방식과 불연속(Non-Contiguous) 방식에 대해 설명해주세요.
```
연속 할당 방식은, 프로세스 이미지가 분리되지 않은 온전한 프로세스를 메인 메모리에 적재하는 방식입니다. 연속 할당 방식에는 크게 2가지가 있으며 '고정 길이 할당'과 '가변 길이 할당'이 있습니다.
고정 길이 할당은 메모리를 고정된 길이로 파트를 분리하고, 프로세스를 해당 파트에 삽입합니다. 고정된 길이의 파트 내에 프로세스가 들어가므로, 여백이 생길 수 있는데 이것을 '내부 단편화'라고 합니다.
가변 길이 할당은 메모리를 프로세스의 길이에 알맞게 파트를 분리하고, 해당 프로세스를 적재합니다. 가변된 길이이므로 내부 단편화는 발생하지 않지만, 가변적인 길이 할당에 의해 일부분이 남으므로 '외부 단편화'가 발생합니다.
 

불연속 할당 방식은, 프로세스가 연속된 이미지가 아닌 분리된 이미지로 구성되어 메인 메모리에 적재하는 방식입니다. '페이징'과 '세그멘테이션' 방식이 있습니다.
페이징은 프로세스를 동일한 크기의 페이지로 분리, 메모리는 해당 페이지와 동일한 크기의 프레임으로 분리해서 메인 메모리에 불연속적으로 저장하는 방식입니다. 단, 내부단편화가 발생할 수 있습니다.
세그멘테이션은 프로세스를 가변적인 크기의 세그먼트로 분리하고 메모리에 적재합니다. 주로 논리적인 블록단위 세그먼트로 Code, Data, Stack & Heap으로 분리할 수 있습니다. 세그멘테이션 역시 '외부 단편화'가 발생할 수 있습니다.
```
<br>
