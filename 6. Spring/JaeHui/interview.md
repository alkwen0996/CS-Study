## 📝 Interview

#### 🗨 POJO 프로그래밍에 대해 설명하세요.

```
POJO란 직역하면 오래된 방식의 간단한 자바 오브젝트라는 의미로, Java로 생성하는 순수한 객체를 의미합니다.
POJO 프로그래밍은 POJO를 이용하여 프로그래밍 코드를 작성하는 것입니다.
순수 자바 객체만을 사용한다고 해서 POJO 프로그래밍이라고 볼 수는 없고, 기본적인 규칙들을 지켜야 합니다.
Spring에서 POJO는 IoC/DI, AOP, PSA를 통해 달성할 수 있습니다.

1️⃣ Java나 Java 스펙에 정의된 것 이외에는 다른 기술이나 규약에 얽매이지 않아야 합니다.
자바 이외에 웹 프레임워크에서 지원하는 클래스 등을 사용하게 되면, 기술을 변경해야 할 때 객체지향 설계 기법을 적용하기 어려워지기 때문입니다.

2️⃣ 특정 환경에 종속적이지 않아야 합니다.
특정한 프레임워크에서만 동작이 가능하면 안된다는 의미로, 환경에 독립적이어야 합니다.
따라서 웹 기반의 환경 정보나 웹 기술을 담고 있는 클래스 또는 인터페이스를 사용하면 안됩니다.
```

<br>

#### 🗨 IoC란 무엇인가요?

```
IoC란 직역하면 제어의 역전이라는 의미로, 제어권이 사용자에게 있지 않고 프레임워크에 있는 것을 의미합니다.
객체의 생성부터 생명 주기의 관리까지 모든 객체에 대한 제어권이 바뀐 것으로, 대부분의 프레임워크에서 사용하는 방법입니다.
개발자는 프레임워크에 필요한 부분을 개발해서 끼워 넣기의 형태로 조립하는 방식의 개발을 하게 됩니다.
이렇게 조립된 코드의 최종 호출은 프레임워크 내부에서 결정된 대로 이루어지는 것을 제어의 역전이라고 표현합니다.
Spring Framework에서 지원하는 IoC Container는 POJO의 생명주기를 관리하며, 생성된 인스텐스들에게 추가적인 기능들을 제공합니다.
```

<br>

#### 🗨 Library와 Framework의 차이에 대해 설명하세요.

```
IoC가 적용된 것을 Framework라고 합니다.
라이브러리는 애플리케이션의 흐름을 개발자가 직업 제어하고, 동작 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용하는 형태입니다.
프레임워크는 애플리케이션 코드가 프레임워크에 의해 사용됩니다.
프레임워크 위에 개발한 클래스를 등록한 뒤, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식입니다.
```

<br>

#### 🗨 DI란 무엇인지 설명하고, 그 중 생성자 주입에 대해 자세하게 설명해주세요.

```
DI란 Spring Framework에서 지원하는 IoC의 형태입니다.
클래스 사이의 의존관계를 Bean 설정 정보를 바탕으로 컨테이너가 자동적으로 연결해주는 것을 의미합니다.
개발자는 제어를 직접 담당할 필요 없이, Bean 설정 파일에 의존 관계가 필요하다는 정보를 추가하는 형태로 구현하게 됩니다.
Container가 실행 흐름의 주체가 되어 애플리케이션 코드에 의존 관계를 주입해주게 됩니다.

생성자 주입은 필요한 의존성을 모두 포함하는 클래스의 생성자를 만들고 그 생성자를 통해 의존성을 주입합니다.
즉 생성자에 파라미터를 만들어두고 이를 통해 DI 컨테이너가 의존할 객체의 참조를 넘겨주는 방식입니다.

💡 순환 참조 방지 가능
생성자 주입은 생성자로 객체를 생성하는 시점에 생성자의 인자에 사용되는 빈을 찾거나 생성하여 빈의 생성자를 호출합니다.

💡 final 키워드
불변하는 객체를 생성할 수 있습니다.
런타임에 중에 객체가 변하는 것을 막아 불변성을 유지할 수 있어 오류를 사전에 방지할 수 있습니다.
```

<br>

#### 🗨 Spring Framework와 Spring Boot의 차이에 대해 설명하세요.

```
Spring Framework란 자바 엔터프라이즈 개발을 편하게 해주는 경량급 오픈소스 애플리케이션 프레임워크입니다.
POJO 기반의 Enterprise Application 개발을 쉽고 편하게 할 수 있도록 하는 것이 목표입니다.
자바 애플리케이션을 개발하는 데 필요한 하부 구조(Infrastructure)를 포괄적으로 제공하기 때문에, 개발자는 개발에 집중할 수 있습니다.
동적인 웹 사이트를 개발하기 위한 여러가지 서비스를 제공하며,
대한민국 공공기관의 웹 서비스 개발 시 사용을 권장하고 있는 전자 정보 표준 프레임워크의 기반 기술입니다.

하지만 Spring Legacy 프로젝트는 denpendency를 설정해줄 때 설정 파일이 매우 길고,
모든 denpendency에 대해 버전 관리를 하나 하나 직접 해주어야 하는 번거로움이 있습니다.
또한 configuration 설정을 할 때도 모든 어노테이션 및 Bean 등록 등을 직접 설정해야 합니다.

Spring Boot는 이를 보완하기 위해 스프링으로 애플리케이션을 만들 때 필요한 설정을 간편하게 처리해주는 별도의 프레임워크입니다.
설정 정보를 간략화할 수 있는 이유는 Spring Boot가 기존 복잡한 설정을 대신하고 있기 때문입니다.
초기 설정에 쏟아야 하는 시간과 노력을 절약하여 개발자는 비즈니스 로직을 구현하는 데에 집중할 수 있습니다.

또한 기존 배포 시 별도의 외장 웹 서버를 설치 후 프로젝트를 war 파일로 필드해야 해서 느리고 번거로웠습니다.
Spring Boot는 자체적인 웹 서버를 내장하고 있어 빠르고 간편하게 배포를 진행할 수 있습니다.
독립적으로 실행 가능한 jar 파일로 프로젝트를 빌드할 수 있어 클라우드 서비스 및 도커와 같은 가상화 환경에 빠르게 배포할 수 있습니다.
```

<br>

#### 🗨 Spring에서 Bean 과 Container에 대해 설명하세요.

```
컨테이너에 담겨있으며, 필요할 때 컨테이너에서 가져와서 사용하게 됩니다.
@Bean을 사용하거나 xml 설정을 통해 일반 객체를 Bean으로 등록할 수 있고, Bean으로 등록된 객체는 쉽게 주입하여 사용 가능합니다.

컨테이너란 인스턴스의 생명주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 제공하도록 하는 것을 의미합니다.
개발자가 작성한 코드의 처리 과정을 위임받은 독립적인 객체라고 생각하면 됩니다.
적절한 설정만 되어 있다면 누구의 도움 없이도 개발자가 작성한 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤합니다.
Spring Framework는 다른 프레임워크들과 달리 컨테이너 기능을 제공하는데, 이를 제공 가능하도록 하는 것이 IoC 패턴입니다.
스프링 컨테이너에는 BeanFactory, ApplicationContext 인터페이스가 있습니다.

💡 Spring Container & Bean
AppConfig 클래스 같은 것이 스프링 컨테이너로 @Configuration 사용합니다.
AppConfig 내에서 @Bean이 붙은 것이 Spring Bean을 의미합니다.
```

<br>

#### 🗨 Bean 초기화 방법 중 권장되는 방법에 대해 설명해 주세요.

```
1️⃣ 사용 방법이 간결하며 코드에서 초기화 메소드가 존재함을 쉽게 파악 가능하여 xml 설정 방법보다 직관적입니다. (권장)
초기화: 빈 초기화 메소드에 @PostConstruct 사용하여 xml에 <context:annotation-config></context:annotation-config> 추가
소멸: 빈 소멸 메소드에 `@PreDestroy` 사용하여 xml에 <context:annotation-config></context:annotation-config> 추가
```

<br>

#### 🗨 MVC1 패턴과 MVC2 패턴의 차이에 대해 설명하세요.

```
MVC1 패턴은 JSP 페이지에서 View와 Controller 역할 담당하여 로직 처리를 하게 됩니다.
구조는 단순하지만, JSP 내에서 html과 자바 코드가 함께 사용되어 복잡하고 유지보수가 어렵습니다.

MVC2 패턴은 Model, View, Controller로 모듈화된 형태로, JSP는 로직 처리 없이 Client에게 보여지는 View만 담당하게 됩니다.
구조가 복잡하나 유지보수가 용이합니다.
```

<br>

#### 🗨 DAO, DTO, VO 차이에 대해 설명하세요.

```
DAO(Data Access Object)
DB의 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 객체를 말합니다.
DB에 접근을 하기위한 로직과 비즈니스 로직을 분리하기 위해서 사용합니다.

DTO(Data Transfer Object)
계층간 데이터 교환을 위한 자바 Bean들을 말합니다.
여기서 말하는 계층은 Controller, View, Business Layer, Persistent Layer 입니다.
일반적인 DTO는 로직을 갖고 있지 않는 순수한 데이터 객체이며, 속성과 그 속성에 접근하기 위한 getter, setter 메소드만 가진 클래스입니다.

VO(Value Object)
DTO와 동일한 개념이지만 read only 속성을 가지는 객체입니다.
```

<br>

#### 🗨 Spring Annotation에 대해 몇 가지 설명해주세요.

```
- @ComponentScan: @Service, @Repository, @Controller, @Configuration이 붙은 클래스 Bean들을 찾아서 Context에 bean등록을 해주는 Annotation
- @Component: 개발자가 직접 작성한 Class를 Bean으로 등록하기 위한 Annotation
- @Bean: 개발자가 직접 제어가 불가능한 외부 라이브러리등을 Bean으로 만들려할 때 사용되는 Annotation
- @Autowired: 속성(field), setter method, constructor(생성자)에서 사용하며 Type에 따라 알아서 Bean을 주입해주는 것입니다.
- @Inject: @Autowired 어노테이션과 비슷한 역할
- @Controller: Spring의 Controller로 Spring MVC에서 Controller클래스에 쓰입니다.
- @RestController: Spring에서 Controller 중 View로 응답하지 않는, Controller를 의미합니다.
- @Service: Service Class에서 쓰이는 것으로, 비즈니스 로직을 수행하는 Class라는 것을 나타내는 용도입니다.
- @Repository: DAO class에서 쓰이며, DataBase에 접근하는 method를 가지고 있는 Class에서 쓰입니다.
- @CrossOrigin: CORS 보안상의 문제로 브라우저에서 리소스를 현재 origin에서 다른 곳으로의 AJAX요청을 방지하는 것입니다.
- @RequestBody: 요청이 온 데이터(JSON이나 XML형식)를 바로 Class나 model로 매핑하기 위한 Annotation입니다.
- @PathVariable: method parameter 앞에 사용하면서 해당 URL에서 {특정값}을 변수로 받아 올 수 있습니다.
```

<br>

#### 🗨 @Controller 와 @RestController 의 차이에 대해 설명하세요.

```
💡 @Controller
API와 view를 동시에 사용하는 경우에 사용합니다.
대신 API 서비스로 사용하는 경우는 @ResponseBody를 사용하여 객체를 반환합니다.
view(화면) return이 주목적입니다.

💡 @RestController
view가 필요없는 API만 지원하는 서비스에서 사용합니다.
Spring 4.0.1부터 제공하며, @RequestMapping 메서드가 기본적으로 @ResponseBody 의미를 가정합니다.
data(json, xml 등) return이 주목적입니다.
즉, @RestController = @Controller + @ResponseBody 인 것입니다.
```

<br>

#### 🗨 Lombok Annotation에 대해 몇 가지 설명해주세요.

```
- @NoArgsConstructor: 기본생성자를 자동으로 추가합니다.
- @AllArgsConstructor: 모든 필드 값을 파라미터로 받는 생성자를 추가합니다.
- @RequiredArgsConstructor: final이나 @NonNull인 필드 값만 파라미터로 받는 생성자를 추가합니다. final 값이 할당되면 더 이상 변경할 수 없습니다.
- @Getter: Class 내 모든 필드의 Getter method를 자동 생성합니다.
- @Setter: Class 내 모든 필드의 Setter method를 자동 생성합니다.
- @Builder: 어느 필드에 어떤 값을 채워야 할지 명확하게 정하여 생성 시점에 값을 채워줍니다.
- @Data: @Getter @Setter @EqualsAndHashCode @AllArgsConstructor을 포함한 Lombok에서 제공하는 필드와 관련된 모든 코드를 생성하는 것으로, 전체적인 모든 기능 허용으로 위험 존재하기 때문에 실제로 사용하지 않는것이 좋습니다.
```

<br>

#### 🗨 JPA Annotation에 대해 설명해주세요.

```
- @Entity: 실제 DB의 테이블과 매칭될 Class임을 명시하는 것으로 테이블과 링크될 클래스임을 나타냅니다.
- @Table: Entity Class에 매핑할 테이블 정보를 알려줍니다. @Table(name = "USER")와 같은 형태로 사용되며, Annotation을 생략하면 Class 이름을 테이블 이름 정보로 매핑합니다.
- @Id: 해당 테이블의 PK 필드를 나타냅니다.
- @GeneratedValue: PK의 생성 규칙을 나타냅니다. 가능한 Entity의 PK는 Long 타입의 Auto_increment를 추천하며, 스프링 부트 2.0에선 옵션을 추가해야 auto_increment이 가능합니다. 기본값은 AUTO로, MySQL의 auto_increment와 같이 자동 증가하는 정수형 값이 됩ㄴ디ㅏ.
- @Column: 테이블의 컬럼을 나타내며, 굳이 선언하지 않더라도 해당 Class의 필드는 모두 컬럼이 됩니다. @Column을 생략하면 필드명을 사용해서 컬럼명과 매핑합니다.
```

<br>

#### 🗨 Constructor와 Builder의 차이점에 대해 설명하세요.

```
생성 시점에 값을 채워주는 역할은 똑같지만, Builder를 사용하면 어느 필드에 어떤 값을 채워야 할지 명확하게 인지할 수 있습니다.
해당 Class의 Builder 패턴 Class를 생성 후 생성자 상단에 선언 시 생성자에 포함된 필드만 빌더에 포함됩니다.
```

<br>

#### 🗨 Restful API에 대해 설명하세요.

```
HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,
HTTP Method(POST, GET, PUT, DELETE, PATCH 등)를 통해
해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미합니다.
CRUD는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말입니다.
```

#### 🗨 WS와 WAS의 차이점에 대해 설명하세요.

```
서버란 네트워크를 통해 클라이언트에게 정보나 서비스를 제공하는 컴퓨터 시스템을 의미합니다.

웹 서버는 인터넷을 기반으로 클라이언트에게 웹 서비스를 제공하는 컴퓨터를 의미합니다.
클라이언트 입장에서는 웹 서버에게 URL 주소를 통해 HTTP 통신 규약에 맞게 요청하면 HTML 내용을 응답받게 됩니다.
서버 입장에서는 HTTP 웹 요청이 들어왔을 때 알맞은 데이터를 만들어 응답하는데, 그 데이터는 웹에서 처리할 수 있는 HTML, CSS, js, jpg 등 정적인 데이터로 한정됩니다.
대표적으로 Apache, Nginx 등이 있습니다.

웹 서버에서는 정적인 데이터만 다룰 수 있으므로, 이를 보완하기 비즈니스 로직 처리, DB 연동 등의 문제를 해결하기 위해 WAS가 등장하게 되었습니다.
WAS는 웹 어플리케이션을 실행시켜 기능을 수행하고 그 결과를 웹 서버에 전달하는 일종의 미들웨어로, 동적인 데이터를 제공할 수 있습니다.
웹 서버와 웹 컨테이너의 역할을 합친 형태로, 프로그램 실행 환경 설정, 데이터베이스 접속, 비즈니스 로직 수행 등을 맡습니다.
대표적으로 Tomcat, JEUS, IBM WebSphere가 있습니다.
```

<br>

#### 🗨 Cookie와 Session의 차이점에 대해 설명하세요.

```
쿠키란 클라이언트에 저장된 목적으로 생성한 key-value 형식의 문자열 덩어리를 의미합니다.
HTTP는 Stateless 무상태, Connectionless 비연결성의 특성을 가지기 때문에, 상태 정보를 유지하기 위해 사용합니다.
클라이언트가 서버에 요청을 보내면, 서버는 응답 헤더의 Set-Cookie에 정보를 담고, 이후 클라이언트는 매번 저장된 쿠키를 요청 헤더에 담아 보냅니다.
서버는 쿠키에 담긴 정보를 바탕으로 클라이언트가 누군지 식별하거나 정보를 바탕으로 추천 광고를 띄울 수 있습니다.
각 사용자의 고유 정보 유출 및 조작 위험이 있어 보안에 취약합니다.
또한 용량 제한이 있고, 웹 브라우저 간 공유가 불가능합니다.

세션은 쿠키와 같이 상태 정보를 유지하기 위한 목적으로 사용되지만,
다른 점은 서버에서 클라이언트의 세션 ID를 부여하여 브라우저가 종료되기 전까지 상태 정보를 유지하게 됩니다.
즉 브라우저가 아닌 서버 측에 인증 정보를 저장하고 관리합니다.
유저가 웹사이트에 접속하면 세션이 서버 메모리에 저장되고, 부여된 Session ID를 브라우저 쿠키에 저장합니다.
브라우저는 해당 사이트에 대한 모든 Request에 Session ID를 쿠키에 담아 전송하고, 서버는 그 값을 서버 메모리의 값과 비교하여 인증을 수행합니다.
```

<br>

#### 🗨 JWT란 무엇이며, 어떻게 활용되는지 설명하세요.

```
JWT란 인증에 필요한 정보들을 암호화시킨 JSON 토큰을 의미합니다.
JSON 데이터를 Base64 URL-safe Encode 방식으로 인코딩하여 직렬화한 것입니다.
위변조 방지를 위한 개인키 전자서명도 포함되어 있어, 서버에서는 서명을 검증하는 과정을 거치게 됩니다.
JWT는 Header, Payload, Signature로 이루어져 있습니다.
헤더에는 JWT에서 사용할 타입과 해시 알고리즘의 종류가 담겨 있습니다.
페이로드에는 서버에서 첨부한 사용자 권한 정보와 데이터가 담겨 있습니다.
시그니처 부분에는 개인키 Private key로 서명한 전자서명이 담겨 있습니다.

토큰 기반 인증 시스템은 클라이언트가 서버에 접속했을 때 인증되었다는 의미로 토큰을 부여받는 방식으로 진행됩니다.
이 토큰은 유일한 값으로, 서버에서 클라이언트를 식별할 수 있는 값입니다.
이 방식은 로그인 시 보편적으로 사용되는 방식입니다.
사용자가 로그인을 하면 서버 측에서 토큰을 발생하고, 클라이언트에서는 이 토큰을 쿠키나 스토리지에 저장한 후 HTTP 요청 헤더에 포함시켜 매번 요청을 수행합니다.
서버는 토큰을 검증하고 요청에 응답하게 됩니다.
토큰 자체에 요청한 사람의 정보가 담겨 있기 때문에 DB를 조회하지 않고도 유저를 식별할 수 있습니다.
```

<br>

#### 🗨 CORS란 무엇인가요?

```
CORS란 출처가 다른 자원들을 공유한다는 의미로, 한 출처에서 있는 다른 자원에서 다른 출처에 있는 다른 자원에 접근하도록 하는 개념입니다.
웹 애플리케이션은 리소스가 자신의 출처, 즉 도메인, 프로토콜, 포트 등과 다를 때 CORS HTTP 요청을 실행합니다.

위 URL에서 Protocol, Host, Port가 같으면 동일 출처(Origin)이라고 합니다.
동일 출처 정책이란 다른 출처로부터 조회된 자원들의 읽기 접근을 막아 다른 출처 공격을 예방합니다.
하지만 이는 다른 출처 자원을 가져오는 것을 제한적으로 허용했기 때문에, 다른 출처 리소스에 접근성을 높이기 위해 CORS가 등장했습니다.
```

<br>

#### 🗨 JDBC와 영속성에 대해 설명하세요.

```
영속성이란 데이터를 생성한 프로그램이 종료되더라도 사리지지 않는 데이터의 특성으로,
영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에 프로그램이 종료되면 모두 잃어버리게 됩니다.
따라서 파일 시스템, 관계형 데이터베이스 혹은 객체 데이터베이스 등을 활용하여 데이터를 영구적으로 저장하여 영속성을 부여해야 합니다.

JDBC는 DB에 접근할 수 있도록 Java에서 제공하는 API입니다.
모든 Java Data Access 기술의 근간으로, 모든 Persistence Framework는 내부적으로 JDBC API를 사용합니다.
Persistence Framework는 데이터를 데이터베이스에 저장하는 과정을 도와주고 자동화하는 매개 소프트웨어로,
데이터를 가공하는 자바 객체 층과 데이터를 저장하는 데이터베이스 층 사이를 매끄럽게 연결하는 역할을 합니다.
크게 SQL Mapper와 ORM으로 나뉩니다.
```

<br>

#### 🗨 SQL Mapper와 ORM의 차이에 대해 설명하세요.

```
SQL Mapper란 Object와 SQL의 필드를 매핑하여 데이터를 객체화하는 기술입니다.
객체와 테이블 간의 관계를 매핑하는 것이 아니라, SQL문을 직접 작성하고 쿼리 수행 결과를 어떠한 객체에 매핑할지 바인딩하는 방법입니다.
대표적으로 JdbcTemplate, Mybatis가 있으며, DBMS에 종속적인 문제가 있다는 단점이 있습니다.

MyBatis는 자바에서 SQL Mapper를 지원해주는 프레임워크로, SQL문을 직접 작성하여 쿼리 수행 결과를 객체화할 수 있습니다.
쿼리문을 xml로 분리할 수 있으며 복잡한 쿼리를 작성할 수 있다는 장점이 있습니다.
그러나 객체와 쿼리문을 모두 관리해야 하며, DB CRUD 메소드를 직접 다 구현해야 하는 번거로움이 있습니다.

ORM이란 Object와 DB 테이블을 매핑하여 데이터를 객체화하는 기술입니다.
개발자가 반복적인 SQL을 직접 작성하지 않아도 되어 편리하며 DBMS에 종속적이지 않습니다.
대표적으로 JPA가 있으며, 복잡한 쿼리의 경우 JPQL을 사용하거나 SQL Mapper를 혼용하여 사용 가능합니다.

JPA란 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스입니다.
자바 ORM의 기술 표준으로, CRUD 메소드를 기본으로 제공합니다.
쿼리를 직접 만들지 않아도 되며 객체 중심으로 개발이 가능합니다.
쿼리가 수정되어 데이터 정보가 바뀌면 객체만 수정하면 되어 편리하지만, 복잡한 쿼리 작성이 어렵다는 단점이 있습니다.
```

<br>

#### 🗨 JPQL와 QueryDSL에 대해 설명하세요.

```
JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어를 제공합니다.
따라서 테이블을 대상으로 쿼리 하는 것이 아닌 엔티티 객체를 대상으로 쿼리하게 됩니다.
JPQL은 SQL을 추상화했기 때문에 특정 데이터베이스 SQL에 의존하지 않는 장점이 있습니다.
따라서 JPQL과 SQL의 가장 뚜렷한 차이점은 JPQL은 엔티티 객체를 대상으로 쿼리문을 작성하며, SQL은 데이터베이스 테이블을 대상으로 쿼리문을 작성하는 것입니다.
JPQL은 기본 문자열로 작성되기 때문에 컴파일 시 에러를 발생하지 않는다는 단점이 있습니다.
또한 동적으로 쿼리 언어를 작성하는 데 효율적이지 못합니다.

QueryDSL이란 정적 타입을 이용해서 SQL, JPQL을 코드로 작성할 수 있도록 도와주는 오픈소스 빌더 API입니다.
하이버네이트 쿼리 언어(HQL: Hibernate Query Language)의 쿼리를 타입에 안전하게 생성 및 관리해주는 프레임워크입니다.
JPQL의 단점을 보완하기 위해 등장하여 컴파일 시 오류를 발견하는 것이 가능하며, 복잡하고 동적인 쿼리 작성이 가능합니다.
```

<br>

#### 🗨 Transaction이란 무엇인지 설명하세요.

```
트랜잭션이란 여러 작업을 진행하다가 문제가 생겼을 경우 이전 상태로 롤백하기 위해 사용되는 것을 말합니다.
더 이상 쪼갤 수 없는 최소 작업 단위이며, commit으로 성공하거나 또는 rollback으로 실패 이후 취소 되어야 합니다.

💡 Transaction ACID

- 원자성 Atomicity: 트랜잭션 내의 작업들은 모두 성공 또는 모두 실패한다.
- 일관성 Consistency: 모든 트랜잭션은 일관성 있는 DB 상태를 유지한다. (ex: DB의 무결성 제약 조건 항상 만족)
- 격리성 Isolation: 동시에 실행되는 트랜잭션들은 서로 영향을 미치지 않는다. (ex: 동시에 같은 데이터 수정 X)
- 지속성 Durability: 트랜잭션이 성공적으로 끝나면 그 결과는 항상 기록되어야 한다.

Spring에서는 마치 트랜잭션 코드와 같은 부가 기능 코드가 존재하지 않는 것 처럼 보이기 위해
해당 로직을 클래스 밖으로 빼내서 별도의 모듈로 만드는 AOP(Aspect Oriented Programming, 관점 지향 프로그래밍)를 고안 및 적용할 수 있습니다.
이를 적용한 트랜잭션 어노테이션(@Transactional)을 지원하게 되었다. 이를 적용하면 위와 같은 코드를 핵심 비지니스 로직만 다음과 같이 남길 수 있습니다
```

<br>

#### 🗨 Local Cache와 Global Cache를 비교 설명하세요.

```
캐싱(Caching)은 애플리케이션의 처리 속도를 높여줍니다.
이미 가져온 데이터나 계산된 결과값의 복사본을 저장함으로써 처리 속도를 향상시키며, 이를 통해 향후 요청을 더 빠르게 처리할 수 있습니다.
대부분의 프로그램이 동일한 데이터나 명령어에 반복해서 엑세스하기 때문에 캐싱은 효율적인 아키텍처 패턴입니다.

Local Cache는 서버마다 캐시를 따로 저장하는 방식으로, Memory, Disk와 같은 로컬 서버 장비의 Resource를 이용합니다.
서버 내에서 작동하기 때문에 속도가 빠른 장점이 있지만, 다른 서버의 캐시를 참조하기 어렵다는 단점도 존재합니다.
캐시에 저장된 데이터가 변경되는 경우에는 해당 서버를 제외한 모든 peer에 변경사항을 전달하고 복사하는 과정을 거칩니다.
이 때문에 WAS 인스턴스가 늘어나고, 만약 캐시 저장 데이터 크기가 커지면 성능이 저하되기도 합니다.
대표적으로 Spring에서 사용 가능한 자바 기반 오픈 소스인 Ehcache가 있습니다.

Global Cache는 여러 서버에서 캐시 서버에 접근하여 참조하는 방법입니다.
별도의 캐시 서버를 이용하기 때문에 서버 간 데이터 공유가 쉽고 데이터를 분산하여 저장할 수 있습니다.
하지만 네트워크 트래픽을 사용해야 해서 Local Cache보다는 속도가 느립니다.
Local Cache와 다르게 캐시에 저장된 데이터가 변경되더라도 추가적인 작업이 별도로 필요하지 않습니다.

Redis란 Key, Value 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 비관계형 데이터 베이스 관리 시스템 (DBMS)입니다.
데이터베이스, 캐시, 메세지 브로커로 사용되며 인메모리 데이터 구조를 가진 저장소입니다.
```

<br>

#### 🗨 캐시 서버 구현 패턴 2가지에 대해 설명하세요.

```
데이터 조회 시 사용
💡 Look aside cache
1. 클라이언트가 데이터를 요청
2. 웹서버는 데이터가 존재하는지 Cache 서버에 먼저 확인
3. Cache 서버에 데이터가 있으면 DB에 데이터를 조회하지 않고 Cache 서버에 있는 결과값을 클라이언트에게 바로 반환 (Cache Hit)
4. Cache 서버에 데이터가 없으면 DB에 데이터를 조회하여 Cache 서버에 저장하고 결과값을 클라이언트에게 반환 (Cache Miss)

데이터 추가 시 사용
💡 Write Back
1. 웹서버는 모든 데이터를 Cache 서버에 저장
2. Cache 서버에 특정 시간 동안 데이터가 저장됨
3. Cache 서버에 있는 데이터를 DB에 저장
4. DB에 저장된 Cache 서버의 데이터를 삭제
```

<br>

#### 🗨 Maven과 Gradle에 대해 설명하세요.

```
빌드란 소스코드 파일을 컴퓨터에서 실행할 수 있는 독립적인 형태로 변환하는 과정과 결과를 의미합니다.
즉 작성한 소스코드와 파일 및 자원을 JVM이나 Tomcat과 같은 WAS가 인식할 수 있도록 패키징하는 과정 및 결과물을 나타냅니다.
빌드 관리 도구란 이런 빌드 과정에서 필요한 라이브러리들을 자동으로 관리해주는 도구로, 다음과 같은 작업을 수행합니다.

Maven은 Java 전용 프로젝트 관리 도구로, Lifecycle 관리 목적 빌드 도구이며, Apache Ant의 대안으로 만들어졌습니다.
아파치 라이센스로 배포되는 오프 소스 소프트웨어이고, pom.xml에 종속 관계를 명시합니다.

Gradle은 Maven을 대체할 수 있는 프로젝트 구성 관리 및 범용 빌드 툴입니다.
Ant Builder와 Groovy script를 기반으로 구축되어 기존 Ant의 역할과 배포 스크립트의 기능 모두 사용 가능하며, SpringBoot와 Android에서 주로 사용됩니다.
Maven에 비해 빌드 속도가 10~100배 가량 빠르며,Java, C/C++, Python 등을 지원합니다.

💡 Maven vs Gradle
Gradle은 작업 의존성 그래프에 기반, Maven은 고정적이고 선형적인 단계의 모델에 기반한다는 빌드 접근 방식의 차이점이 있습니다.
Gradle은 캐시를 사용하기 때문에 Maven보다 속도가 훨씬 빠릅니다.
Maven은 멀티 프로젝트에서 특정 설정을 다른 모듈에서 사용하려면 상속 받아야하지만, Gradle은 설정 주입 방식을 사용하므로 멀티 프로젝트에 적합합니다.
```

<br>

#### 🗨 Filter, Interceptor, AOP를 비교 설명하세요.

```
애플리케이션을 개발할 때 세션 및 권한 체크, XSS 방어, 분기처리, 로그, 페이지 인코딩 변환 등 공통 업무에 관련된 중복된 코드가 많아질 수 있습니다.
이는 프로젝트가 커질수록 서버에 부하를 줄 수 있고 소스 코드 관리가 어렵습니다.
따라서 공통 부분을 따로 빼서 관리해야 할 필요성이 있습니다.

Filter는 요청과 응답을 거른 뒤 정제하는 역할을 합니다.
DispatcherServlet 이전 혹은 맨 마지막에 실행되기 때문에
요청 내용 변경, 전처리 또는 응답 내용 변경, 인코딩 변환, XSS 방어 등을 수행할 수 있습니다.

Interceptor는 요청에 대한 작업 전/후를 가로채서(끼어들어) 기능을 수행하게 됩니다.
Spring Context 내부에서 Controller의 요청과 응답에 관여하며 모든 Bean에 접근이 가능합니다.
로그인 체크, 권한 체크, 로그 확인 등의 작업을 주로 수행합니다.

AOP란 OOP를 보완하기 위해 나온 개념으로, 관점(종단면)을 기준으로 묶어 개발하는 방식을 의미합니다.
관점이란 어떤 기능을 구현할 때 그 기능을 핵심 기능과 부가 기능으로 구분해 각각을 하나의 관점으로 보는 것을 의미합니다.
부가 기능은 핵심 기능이 어떤 기능인지에 무관하게 로직이 수행되기 전 또는 후에 수행되도록 함으로서,
소스 코드에서 여러번 반복해서 쓰는 코드, 즉 흩어진 관심사(Corcern)을 Aspect로 모듈화하여 핵심 로직에서 분리하고 재사용이 용이하도록 합니다.
모듈화된 객체를 편하게 적용할 수 있게 함으로써 개발자가 비즈니스 로직을 구현하는 데만 집중할 수 있게 도와줍니다
```
