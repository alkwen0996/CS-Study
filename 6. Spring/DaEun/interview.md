## 📝 Interview

## Spring Framework
#### 🗨 Spring과 Spring Boot의 차이점에 대해 설명해주세요.
```
스프링은 엔터프라이즈급 어플리케이션을 개발하는데 필요한 다양한 기능을 제공해주는 자바 기반의 어플리케이션 프레임워크입니다.
스프링 프레임워크는 여러 기능을 모듈화하여 필요한 부분만 선택 사용할 수 있도록 설계되어 있습니다.

스프링에서 다양한 기능을 사용하기 위해 개발자는 직접 복잡한 설정 파일을 작성해야 하는데,
이런 과정을 생략하여 스프링 프레임워크를 보다 쉽게 사용할 수 있도록 만든 스프링의 서브 프로젝트가 스프링부트입니다.

스프링부트는 spring-boot=starter 라이브러리를 이용해 라이브러리 간 의존성을 자동으로 관리해주고,
내장 WAS 서버인 톰캣을 제공하는 등 간편하게 스프링을 사용할 수 있도록 도와줍니다.
```

#### 🗨 Spring의 3개 핵심 개념 (Spring 삼각형)에 대해 설명해주세요.
```
스프링 프레임워크는 3가지 핵심 개념을 통해 POJO 기반의 어플리케이션을 작성할 수 있도록 도와주는데,
3가지 핵심 개념은 IoC/DI, AOP, PSA입니다.

IoC/DI는 제어의 역전과 의존성 주입을 뜻하는 말로 객체의 생명주기와 의존성 관리를 개발자가 아닌
스프링에게 위임하는 것을 제어의 역전이라고 말하며, IoC의 구체적인 방법 중 하나라 의존성 주입(DI)입니다. 

AOP는 관점지향 프로그래밍으로 소프트웨어의 관심사를 분리합니다.
관심사는 비즈니스 로직 자체인 핵심 관심과
로깅, 트랜잭션 관리와 같이 여러 곳에서 공통적으로 사용할 수 있는 공통관심으로 나뉩니다.
이런 공통 관심을 분리하여 모듈화하는 기법을 관점지향 프로그래밍이라고 합니다.

PSA는 이식 가능한 서비스의 추상화로 환경과 세부기술의 변경에 관계없이
일관된 방식으로 기술에 접근할 수 있게 해주는 추상화 구조를 말합니다.
즉, 스프링에서 제공하는 다양한 기능과 기술들은 POJO원칙을 따라 추상화되어 개발자에게 제공됩니다. 

```

#### 🗨 POJO 프로그래밍에 대해 설명하세요.
```
우선, POJO는 특정 프레임워크나 라이브러리에 종속적이지 않은 객체지향 원리에 충실한 자바 객체를 의미합니다.
POJO에 어플리케이션의 핵심 로직과 기능을 담아 설계하는 방법을 POJO 프로그래밍이라고하며
스프링은 POJO 프로그래밍을 지향하고 있습니다. 

POJO 프로그래밍을 통해 재사용성이 높고 확장성이 유연한 어플리케이션을 작성할 수 있으며
저수준 레벨의 기술관련 코드가 제거되어 코드의 간결성이 보장됩니다.
또한 테스트가 용이하고 객체지향 설계를 자유롭게 적용할 수 있다는 장점이 있습니다. 
```

#### 🗨 @Controller 와 @RestController 의 차이에 대해 설명하세요.
```
@Controller는 전통적인 Spring MVC의 컨트롤러에 사용되는 어노테이션이고,
@RestController는 RESTful한 웹 서비스의 컨트롤러에 사용되는 어노테이션으로
@Controller와 @ResponseBody가 합쳐져있는 어노테이션입니다.

기본적으로 Spring MVC에서 사용되는 @Controller의 역할은
model 객체를 만들어 데이터를 담아 view를 반환하지만
@RestController는 단순히 데이터 객체만 반환하여 JSON 또는 XML 형식으로 HTTP 응답에 담아 전송하는 데에 사용됩니다.
따라서 @Controller가 붙은 컨트롤러에서는 객체를 반환할 때 @ResponseBody를 명시해야 하지만
@RestController가 붙은 컨트롤러는 명시하지 않아도 반환값에 자동으로 붙게 되어 HTTP 응답에 매핑됩니다. 
```

#### 🗨 Constructor와 Builder의 차이점에 대해 설명하세요.
```
객체 생성 시 생성자를 사용하는 방법과 빌더패턴을 사용하는 방법이 있습니다. 

생성자를 이용하면, 원하는 매개변수의 조합에 따라 생성자를 별도로 정의해야하며
생성자 호출시 매개변수의 전달 순서를 지켜야 합니다. 

빌더 패턴은 별도의 빌더 클래스를 만들어 메서드를 통해 원하는 속성 값을 입력 받은 후
최종적으로 build() 메서드를 통해 하나의 객체를 생성하는 방법입니다.
이 패턴은 선택적 매개변수가 많을 때 유용한데, 생성자로 넘겨야 하는 매개변수가 많을 때
여러 생성자 정의 없이 원하는 속성값만 선택적으로 순서 상관없이 전달하여 객체를 생성할 수 있습니다. 
```

#### 🗨 Spring Annotation에 대해 몇 가지 설명해주세요.
```
@SpringBootApplication: 스프링 부트를 자동으로 실행해주는 어노테이션 (@Comfiguration + @ComponentScan + @EnableAutoConfiguration)

@ComponentScan: 컴포넌트 스캐너의 대상이 되는 클래스들을 발견해 빈으로 등록

@EnableAutoCongifuration: 정의해둔 자바 설정 파일들을 빈으로 등록해 다양한 자동 설정을 적용

@Component: 해당 클래스를 스프링 빈으로 등록해 컴포넌트 스캐너의 대상이 됨

@Autowired: 의존성 주입을 위한 어노테이션으로 객체의 타입과 매핑하여 객체를 탐색하고 의존성을 주입함

@Controller: Spring MVC에서 컨트롤러의 역할을 하는 클래스를 명시

@RestController: RESTful 서비스의 컨트롤러를 명시하는 어노테이션으로 @Controller와 @ResponseBody를 합친 것

```

#### 🗨 Library와 Framework의 차이에 대해 설명하세요.
```
라이브러리와 프레임워크는 모두 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것을 의미합니다.
하지만 어플리케이션의 흐름을 제어하는 주체가 누구냐에 따라 두 가지 도구에서 차이점이 드러납니다. 

라이브러리를 사용하는 어플리케이션은 개발자가 어플리케이션의 흐름을 직접 제어하고
필요한 기능이 있을 때 개발자가 능동적으로 라이브러리를 사용합니다.

반면 프레임워크는 어플리케이션의 흐름이 프레임워크에 의해 제어됩니다. 

라이브러리의 예시로는 tensorflow, pandas와 같이 Python에서 pip로 설치한 패키지나
node.js에서 npm으로 설치한 것 모듈들, JQuery 등을 들 수 있습니다.

프레임워크는 Spring, flask, Django, Vue.js 등을 예시로 들 수 있습니다.
```


<br>

## IoC와 DI
#### 🗨 IoC에 대해 설명해주세요.
```
IoC는 제어의 역행으로 스프링의 핵심 기능입니다.
기존에 개발자에게 객체 생성 및 의존 관계의 모든 제어권이 존재했던 것을 스프링 컨테이너에게 위임하는 것을 말합니다.
객체에 대한 제어권을 스프링에게 위임하여 개발자는 비즈니스 로직을 작성하는 것에 더 집중할 수 있으며,
객체 간의 결합도를 떨어뜨려 재사용성이 올라가고 유지보수가 용이해집니다.
```

#### 🗨 스프링 빈에 대해 설명해주세요.
```
IoC를 위해 스프링 컨테이너가 관리하는 자바 객체를 스프링 빈이라고 합니다. 

기존에는 자바에서 사용되던 객체들을 클래스를 생성하고 개발자가 필요한 객체에서
new 키워드를 사용해 원하는 객체를 직접 생성하고 사용했습니다.
하지만 스프링에선 IoC를 통해 컨테이너가 객체를 생성하고 관리해 객체 간 결합도를 낮추는데
이때 스프링에 의해 관리되는 자바 객체를 스프링 빈이라고 합니다. 

스프링에선 기본적으로 싱글톤 패턴을 이용해 하나의 인스턴트만 생성되고,
팩토리 패턴에서 팩토리 메서드에 해당하는 역할이 스프링 컨테이너입니다.
```

#### 🗨 스프링 컨테이너에 대해 설명해주세요.
```
스프링에서 객체의 생성, 사용, 소멸 등 빈의 라이프사이클을 관리하고
어플리케이션 사용에 필요한 주요 기능을 담당합니다.
스프링 컨테이너로 인해 개발자는 팩토리 패턴, 싱글톤 패턴을 직접 구현하지 않아도 됩니다.

스프링 컨테이너는 ApplicationContext 인터페이스를 이용해 구현되며
ApplicationContext는 BeanFactory를 상속받아 빈의 생명주기를 관리하고 추가로 부가 서비스를 추가 제공합니다.
```

#### 🗨 팩토리 패턴과 싱글톤 패턴에 대해 설명해주세요.
```
팩토리 패턴은 객체를 사용하는 코드에서 객체 생성 부분은 떼어내 추상화하는 것을 말합니다.
외부의 팩토리 메서들를 통해 객체를 생성하기 때문에 객체 간 결합도가 느슨해집니다. 

스프링에선 팩토리 메서드에 해당하는 객체가 스프링 컨테이너이며
스프링 컨테이너에서 객체의 생성 및 생명주기를 관리하여 결합도를 떨어뜨립니다.
팩토리 패턴에서는 객체가 팩토리 메서드를 의존하게되지만,
스프링에서 객체는 어떤 것에도 의존하지 않고 컨테이너가 생성한 객체에 대한 의존성을 주입하는 방식을 사용합니다. 

싱글톤 패턴은 하나의 클래스에 대해 하나의 인스턴스만 가지는 것을 말합니다.
클래스에 대한 인스턴스를 여러개가 아닌 하나만 만들어 필요한 곳에서 공유됩니다. 

스프링 빈은 기본적으로 생성될 때 싱글톤 패턴을 기반으로 생성됩니다. 
```

#### 🗨 DI의 방법에 대해 설명해주세요. 
```
IoC의 구체적인 구현 방법 중 하나로 객체 간의 의존관계를 개발자가 아닌
스프링 컨테이너가 수행하는 것을 말합니다. DI를 통해 객체 간 결합도를 낮출 수 있습니다. 

DI는 크게 두가지 방법으로 분류할 수 있는데, 생성자를 통한 DI와 Setter를 통한 DI가 있습니다.
생성자를 통한 DI는 컴포넌트를 변경 불가능한 객체로 구현하고 필요한 종속성이 주입되지 않는 것을 방지할 수 있기 때문에,
스프링에서는 일반적으로 생성자를 통한 DI 방법을 권장합니다. 
```

<br>

## DAO, DTO, VO

#### 🗨 DAO, DTO, VO 차이에 대해 설명하세요.
```
모두 데이터를 저장하기 위한 객체를 말합니다. 

DAO는 Data Access Object의 약자로
데이터베이스의 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 객체를 의미합니다.

DTO는 Data Transfer Object의 약자로
계층간 데이터 교환을 위한 객체를 말합니다.
일반적으로 DTO는 로직을 가지고 있지 않은 순수한 객체로
속성과 속성을 읽고 쓸 수 있는 getter, setter 메서드만 가집니다. 

VO는 Value Object의 약자로 DTO와 유사한 개념이지만
Read Only한 속성을 가지고 있어 데이터 자체를 나타내는 객체입니다.
따라서 값 자체를 표현하고자 할 때 사용됩니다. 
```

<br>

## RESTful API

#### 🗨 Restful API에 대해 설명하세요.
```
RESTful API란 REST를 기반으로 만들어진 API를 RESTful API라고 합니다.
REST란 자원을 URI로 명시하고 HTTP 메서드를 이용해 클라이언트와 해당 자원을 원하는 형태로 주고받는 것을 말합니다. 
```

<br>

## WS와 WAS

#### 🗨 WS와 WAS의 차이점에 대해 설명해주세요.
```
Web Server는 정적 페이지를 제공하는 서버를 말하고, 
Web Application Server는 동적 페이지를 제공하는 서버를 말합니다. 

WAS는 보통 WS 기능 또한 내제하고 있어 정적 페이지를 요구할 경우 WS에서 바로 해당 요청을 처리하고,
동적 컨텐츠를 요구할 경우 웹 컨테이너에 요청을 보내 동적 페이지를 생성합니다. 

WAS의 웹 컨테이너(서블릿 컨테이너)가 DB 조회 및 다양한 로직 처리가 요구되는 동적 페이지를 처리하기 때문에 WAS를 웹 컨테이너라고도 합니다.

WS에는 Apache Server, NginX 등이 있고
WAS에는 Apache Tomcat Server, JAVE EE, JBoss 등이 있습니다.

```

#### 🗨 WAS에 있는 웹 컨테이너의 역할에 대해 설명해주세요.
```
서블릿 컨테이너라고도 불리는 웹 컨테이너는 
JSP, Servlet과 같은 서버 측 컴포넌트를 실행시켜 
동적 컨텐츠를 생성하고 WS에 제공하는 역할을 합니다.

여기서 JSP와 Servlet은 웹 클라이언트에 대한 요청에 동적으로 처리할 수 있는 기술을 말합니다.

웹 컨테이너의 동작 방식은 다음과 같음

1. 웹서버(WS)에게 요청 전달 받음
2. web.xml을 참고해 해당 서블릿의 쓰레드와 httpServletRequest, httpServletResponse 객체 생성
3. 해당 서블릿 호출
4. 생성된 쓰레드가 doPost(), doGet()을 호출
5. 호출된 doPost(), doGet() 메서드는 생성된 동적 페이지를 Resonse 객체에 담아 컨테이너에 전달
6. 전달받은 Response를 HTTP Response 형태로 바꿔 웹 서버에 전달
7. 쓰레드 종료 및 생성한 객체 소멸

```

#### 🗨 Servlet과 JSP 차이점에 대해 설명해주세요.
```
두 기술 모두 클라이언트에 대한 요청에 동적으로 처리할 수 있는 기술을 말하며, 
서블릿과 JSP는 기능에 대한 차이는 없고 역할의 차이만 존재합니다.

서블릿은 요청에 대한 동적인 처리가 가능한 하나의 자바 클래스입니다. 즉, 서버 사이드에서 동작하는 자바 프로그램을 말하며 자바 코드 안에 HTML 코드가 존재합니다.

JSP는 요청에 대한 동적인 처리가 가능한 스크립트 언어입니다. 즉, 서버 사이드에서 동작하는 자바 기반의 스크립트 언어로 HTML 코드 안에 Java 코드가 존재합니다. 
서블릿을 보안한 방식으로 스크립트 방식의 표준이며, 내부적으로 JSP 파일은 자동으로 Servlet으로 변환됩니다.

서블릿은 데이터 프로세싱 즉, 컨트롤러 역할에 좋으며 JSP는 프레젠테이션 즉, 뷰 역할에 적합합니다. 서블릿은 변경이 있으면 컴파일 및 재배포 과정이 필요한 반면 JSP 수정 후 재배포가 필요 없습니다. (WAS가 자동으로 다시 컴파일해 반영함)
```

<br>

## 빌드 관리 도구

#### 🗨 컴파일과 빌드의 차이점에 대해 설명해주세요.
```
컴파일은 소스코드를 기계어로 변환하는 과정이고
빌드는 컴파일한 결과물을 포함해 프로젝트의 여러 구성요소를 합쳐, 
실행 및 배포 가능한 프로그램으로 만드는 과정입니다.
```

#### 🗨 빌드 과정에 대해 간략히 설명해주세요.
```
[컴파일 → 링크 → 패키징 → 테스트] 과정을 거칩니다.

컴파일 단계에선 소스코드(.java)를 바이너리 코드로 변환하고
링크 단계에선 외부 라이브러리를 포함해서 클래스 파일들끼리 연결하는 작업을 합니다.
패키징 단계에선 연결된 클래스 및 리소스 파일을 묶는 작업을 하고
테스트 단계에선 기능 테스트를 진행합니다.
```

#### 🗨 JAR와 WAR의 차이
```
JAR(Java ARchive)와 WAR(Web Application aRchive)은 자바 프로젝트의 빌드 산출물로,  
두 가지 다른 종류의 Java 압축 파일 형식입니다.

JAR 파일은 일반적으로 독립적으로 실행 가능한 Java 애플리케이션을 패키징할 때 사용되고, 
WAR 파일은 Java 웹 애플리케이션을 패키징할 때 사용됩니다.

JAR는 클래스 파일과 리소스 파일로 구성되어 있고,
WAR는 웹 관련 자원들 추가적으로 포함하고 있습니다.
WAR는 별도의 WS 또는 WAS가 필요합니다. 
```

#### 🗨 Maven과 Gradle을 비교해주세요.
```
Maven과 Gradle은 모두 자바 어플리케이션에 사용되는 빌드 관리 도구로 외부 라이브러리들을 자동 추가 및 관리해주어 개발자들에게 편의성을 제공해줍니다. 

Maven은 XML 기반 빌드 관리 도구로, pom.xml 파일에 프로젝트 구조, 의존성, 빌드 프로세스 등을 정의합니다.
또한 pom.xml 파일에 작성한 라이브러리를 네트워크를 통해 중앙 저장소인 maven repository에서 자동으로 다운받고 종속성을 관리해줍니다. 많은 사용자가 Maven을 이용하고 있어 커뮤니티가 활성화되어 있다는 장점이 있습니다. 

Gradle은 XML 파일이 아닌 Groovy나 Kotlin과 같은 스크립트 언어를 사용해 프로젝트를 설정하는 빌드 관리 도구입니다. 따라서 가독성이 떨어지는 XML의 단점을 보완하고 유연함과 성능에 초점을 둔 빌드 도구입니다. 빌드 캐시 기능을 제공하며 빌드 속도가 Maven보다 빠르다는 장점이 있습니다.  
```

<br>

## ORM과 SQL Mapper

#### 🗨 데이터의 영속성이 무엇인지, 데이터에 영속성을 부여하려면 어떻게 해야하는지 설명해주세요.
```
영속성이란 데이터를 생성한 프로그램이 종료되어도 데이터가 사라지지 않는 특징을 말합니다. 
영속성을 갖지 않는 데이터는 메모리에서만 존재하기 때문에 프로그램이 종료되면 모두 사라집니다. 
따라서 데이터에 영속성을 부여하기 위해선, 파일시스템이나 데이터베이스에 저장하여 프로그램이 종료되어도 사라지지 않게 합니다.  
```

#### 🗨 JDBC가 무엇인지 설명하고 사용하는 과정에 대해 간략히 말씀해주세요.
```
JDBC는 자바에서 DB에 접근할 수 있도록 제공하는 API를 말하며 DBMS 종류에 상관없이 이용할 수 있습니다. 
모든 영속성 프레임워크는 JDBC를 사용합니다.

순수 JDBC를 사용하는 과정은 다음과 같습니다. 
1. JDBC 드라이버 로드
2. 데이터베이스와 연결
3. 쿼리 생성
4. 결과 처리
5. 리소스 반납
이런 과정을 매번 반복해야 하는 번거로움을 줄이기 위해 SQL Mapper나 ORM과 같은 영속성 프레임워크를 사용합니다.
```

#### 🗨 ORM과 SQL Mapper의 차이점에 대해 설명해주세요.
```
ORM과 SQL Mapper는 모두 영속성 프레임워크로 데이터베이스와 상호작용하는 데 사용되는 도구입니다. 

ORM은 자바 객체와 데이터베이스의 테이블을 자동으로 매핑해주는 기술이고, SQL Mapper는 개발자가 직접 작성한 SQL 쿼리의 수행 결과를 특정 자바 객체에 매핑해주는 기술입니다. 

SQL Mapper는 개발자가 직접 쿼리를 작성해야 하기 때문에 복잡한 쿼리를 다룰 때 용이하지만, SQL에 의존적이고 SQL은 DBMS마다 상이하기 때문에 결국 DBMS에 종속적이라는 특징을 가지고 있습니다. 

ORM은 CRUD관련 메서드를 사용하면 자동으로 SQL이 생성되기 때문에 쿼리를 직접 개발자가 작성할 필요가 없습니다. DBMS에 의존적이지 않아 비즈니스 로직 설계에 집중할 수 있다는 장점이 있습니다.
```

#### 🗨 MyBatis와 JPA를 함께 사용할 수 있을까요?
```
네, 가능합니다. 
MyBatis는 SQL Mapper로 사용자가 SQL을 직접 작성해 복잡한 쿼리를 다루는 데 이점이 있습니다.

JPA는 ORM으로 객체와 테이블을 자동으로 매핑해 더욱 객체 지향 프로그래밍에 적합한 방식으로 데이터를 다룰 수 있다는 장점이 있습니다. 

따라서 두 기술을 함께 사용할 경우 복잡한 쿼리와 성능 최적화는 MyBatis로 간단한 CRUD작업은 JPA로  혼합하여 처리할 수 있습니다. 
```

## 필터와 인터셉터

#### 🗨 필터와 인터셉터의 차이에 대해 설명해주세요.
```
필터와 인터셉터는 공통적으로 여러 작업을 처리해 중복된 코드를 제거할 수 있는 기능을 말합니다. 

필터는 디스패처 서블릿에 요청이 전달되기 전후에 URL 패턴에 맞는 모든 요청에 대한 부가 작업을 처리합니다.

인터셉터는 디스패처 서블릿이 컨트롤러를 호출하기 전후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공합니다.

또한 필터는 웹 컨테이너가 관리하는 자바 기능이고, 인터셉터는 스프링 컨테이너가 관리하는 스프링 기능입니다. 

따라서 필터는 Request나 Response 객체를 조작할 수 있지만 인터셉터는 조작할 수 없습니다.

필터는 공통된 보안, 인증, 인가 작업이나 모든 요청에 대한 로깅 기능 등에 사용되고, 
인터셉터는 세부적인 보안 기능 API 호출에 대한 로깅에 사용됩니다. 
```

#### 🗨 필터 인터페이스의 각 메서드에 대해 설명해주세요.
```
필터에는 init(), doFilter(), destroy() 메서드가 존재합니다.

init()은 웹 컨테이너가 한 번만 호출하여 필터 객체를 초기화하고 서비스에 추가하기 위한 메서드입니다.

doFilter()는 URL 패턴에 맞는 모든 HTTP 요청이 디스패처 서블릿으로 전달되기 전에 웹 컨테이너에 의해 실행되는 메서드입니다. 
FilterChain 파라미터의 doFilter를 통해 다음 대상으로 요청을 전달할 수 있습니다. 이를 필터 체이닝이라고 합니다.

destroy()는 필터 객체를 서비스에서 제거하고 자원을 반환하기 위한 메서드입니다.
```

#### 🗨 인터셉터 인터페이스의 각 메서드에 대해 설명해주세요.
```
preHandle(), postHandle(), afterCompletion() 메서드가 존재합니다. 

preHandle()은 컨트롤러가 호출되기 전에 실행되는 메서드로 컨트롤러 이전에 처리해야 하는 전처리 작업이나 요청 정보를 가공하는 경우 사용됩니다. 반환타입이 boolean값으로 여러 인터셉터가 존재할 때 웹 컨테이너가 반복문을 통해 순차적으로 preHandle()을 실행시켜 반환값이 false면 요청이 중단되는 식으로 동작합니다.

postHandle()은 컨트롤러가 호출된 이후에 실행되는 메서드입니다. 컨트롤러 하위 계층에서 예외가 발생되면 postHandle()은 호출되지 않습니다.

afterCompletion()은 뷰 페이지가 렌더링되고 난 후, 즉 모든 작업이 완료된 후 실행되는 메서드입니다. 주로 사용한 리소스를 반납할 때 사용되며 컨트롤러 하위 계층에서 예외가 발생해도 afterCompletion()은 반드시 호출됩니다.
```
