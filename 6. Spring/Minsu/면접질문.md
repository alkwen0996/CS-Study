## 📝 Interview

#### 🗨 Spring Framework과 SpringBoot의 차이점에 대해 설명해주세요.

```
Spring Framework란 엔터프라이즈용 Java 기반 애플리케이션 개발을 위한 오픈소스 경량 애플리케이션 프레임 워크로 순수 자바 객체 ( POJO ) 만을 사용하여 복잡성을 제거하고 단순하고 가벼운 코드로 기업용 애플리케이션 개발하기 위한 목적으로 만들어진 프로젝트를 말합니다.

Spring Framework는 IOC, DI, AOP 등의 핵심기능을 토대로 객체지향의 특징을 잘 활용하여 애플리케이션을 개발할 수 있도록 하며 엔트프라이즈 기술을 처리하는 코드와 핵심 비즈니스 로직을 분리하여 개발자들이 핵심 비즈니스 로직에 더 집중할 수 있도록 합니다.

Spring Boot는 Spring 프로젝트 중 하나로 Spring Frameowork의 복잡한 설정을 간소화하여 보다 쉽고 빠르게 애플리케이션을 개발할 수 있도록 기능을 제공하는 도구입니다.

Spring Boot에서 제공하는 대표적인 간편한 기능으로는 내장서버 제공, 의존성 및 권장버전관리, 빈 자동설정, actuator를 통한 모니터링 기능이 있습니다.
```

#### 🗨 의존성 주입의 3가지 방법에 대해 설명해주세요.

```
1. 생성자를 이용한 주입방법
2. setter를 이용한 주입방법
3. 필드에 @Autowired를 이용한 주입방법
```

#### 🗨 RESTFul API란 무엇인지 설명해주세요.

```
RESTful API란 REST의 원리를 기반으로 서비스의 API를 구현한것을 의미합니다.
Rest란 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 방법으로 URI를 통해 자원을 명시하고 HTTP Method를 통해 자원에 대한 상태를 표현하는 것을 의미합니다.
```

#### 🗨 HTTP Method란 무엇인가요?

```
HTTP 메서드는 클라이언트가 웹 서버에게 사용자 요청의 목적이나 종류를 알리는 수단으로 자주 사용하는 HTTP Method로는 GET, POST, PUT, DELETE 등이 있습니다.
```

#### 🗨 MVC 패턴이란 무엇인지 설명해주세요.

```
MVC 패턴이란 애플리케이션의 구조를 데이터와 비즈니스 로직을 담당하는 Model 그리고 프로그램의 흐름을 제어하는 역할을 하는 Controller 마지막으로 사용자들에게 화면을 제공하는 View 세가지 영역으로 구분한 개발 방법론을 이야기 합니다. 각 컴포넌트의 변경이 다른 영역의 컴포넌트에 영향을 미치지 않아 컴포넌트간의 결합성이 낮은 특징이 있으며 이로 인해 유지보수에 용이하고 확장성이 뛰어납니다.
```

#### 🗨 DTO와 DAO의 차이에 대해 설명해주세요.

```
DAO와 DTO는 모두 Data에 관련된 객체입니다.

먼저, DAO는 DB의 데이터에 접근할 때 사용하기 위한 객체입니다. DB에 접근하여 삽입, 삭제, 조회 등 데이터를 조작할 수 있는 기능을 수행할 때 사용되며 DB에 접근하기 위한 로직과 비즈니스 로직을 분리하기 위해 사용합니다.

DTO는 계층 간 데이터를 교환할 때 사용하는 객체로 로직을 가지지 않는 순수한 데이터 객체를 의미합니다. getter와setter 메서드를 가질 수 있으며 주로 View와 Controller 사이에서 데이터를 주고 받을 때 활용하며 비즈니스 로직은 포함되지 않는 특징이 있습니다.
```

#### 🗨 AOP란?

```
공통 관심사의 분리를 허용함으로써 모듈성을 증가시키는 것이 목적인 프로그래밍 패러다임을 말합니다. OOP로 독립적으로 분리하기 어려운 부가 기능을 모듈화하는 방식으로 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어 여러 객체에 공통으로 적용할 수 있는 기능을 분리하여 개발자는 반복 작업을 줄이고 핵심 기능 개발에만 집중할 수 있게 된다는 특징이 있습니다.
```

#### 🗨 Maven과 Gradle에 대해 각각 설명하세요.

```
자바 프로젝트를 위한 빌드 자동화 도구로 프로젝트의 전체적인 라이프 사이클을 관리해주는 관리도구이다. 프로젝트 객체모델 ( Project Object Model: POM ) 개념을 바탕으로 프로젝트의 의존성 관리, 라이브러리 관리, 프로젝트 라이프사이클 관리 등의 기능을 제공한다. xml 스크립트를 기반으로 하며 pom.xml 파일로 의존성을 관리한다.

Gradle은 Groovy 언어를 사용하는 빌드 자동화 도구로 현재 안드로이드 프로젝트의 공식 빌드 도구로 채택되어 있다. Java 뿐만 아니라 C/C++ 그리고 Python 등 여러가지 언어를 지원한다. Gradle 은 build.gradle 파일에 Groovy 기반의 DSL을 사용하여 스크립트를 작성하며 대규모 프로젝트에서 복잡해지는 경향이 있는 xml 스크립트에 비해 스크립트 길이와 가독성 측면에서 강점을 보인다.
```

#### 🗨 SQL Mapper와 ORM에 대해 각각 설명하세요.

```
SQL Mapper란 `Java Persistence Framework` 중 하나로 직접 작성한 `SQL` 문의 질의 결과와 객체의 필드를 매핑하여 데이터를 객체화 한다. `SQL Mapper` 에속하는 대표적인 프레임 워크로 `MyBatis` 가 있다.


ORM이란 객체와 관계형 데이터베이스의 관계를 매핑해주는 프로그래밍 기법이다. ORM 은 객체간의 관계를 바탕으로 SQL 을 자동으로 생성하고 직관적인 메서드로 데이터를 조작할 수 있도록 기능을 제공한다. ORM 의 대표적인 예로는 JPA 가 있다.
```

#### 🗨 MyBatis 와 JPA 차이점

```
`MyBatis` 는 `SQL` 문의 질의 결과와 객체의 필드를 매핑하여 데이터를 객체화 하는 `SQL Mapper`의 한종류로 `SQL`을 `XML` 파일에 작성할 수 있도록 하여 `DAO` 로직과 `SQL` 을 분리하여 관리할 수 있도록 해준다. `SQL` 을 직접 작성해야 하기 때문에 최적화된 쿼리를 구현하고 복잡한 쿼리를 작성할 수 있다는 장점이 있으나 직접적인 쿼리 작성으로 인한 휴먼에러의 가능성이 있고 반복적인 쿼리를 작성해야 하며 스키마 변경시 쿼리를 일일히 수정해야 한다는 단점이 있다.

반면, JPA는 객체와 관계형 데이터베이스의 관계를 매핑해주는 프로그래밍 기법으로 객체간의 관계를 바탕으로 `SQL` 을 자동으로 생성하고 직관적인 메서드로 데이터를 조작할 수 있도록 기능을 제공한다. 이를 통해 `MyBatis`의 단점인 반복적인 쿼리작성 그리고 SQL 작성으로 인해 발생할 수 있는 휴먼에러 등의 문제점을 해결할 수 있으며 스키마 변경시 엔티티만 변경하면 되기 때문에 유지보수 측면에서도 강점을 보인다. 하지만, 로직이 복잡하면 불필요한 쿼리가 발생할 가능성이 있다는 단점도 존재한다.
```

#### 🗨 MyBatis 와 JPA 를 함께 사용해서 얻을 수 있는 장점

```
JPA는 직관적인 메서드를 통해 쿼리를 자동으로 생성해주는 기능을 제공한다. 따라서 직접적 쿼리를 작성할 수 없기에 로직이 복잡할 경우 불필요한 쿼리가 발생할 수 있다는 한계가 있다. 이런 한계를 MyBatis를 함께 사용하여 보완할 수 있다. 단순 반복적인 쿼리는 JPA를 통해 처리하며 MyBatis를 통해 복잡한 쿼리를 직접 작성하여 최적화된 쿼리를 구현할 수 있다.
```

#### 🗨 JPA Dirty Checking이란?

```
트랜잭션 안에서 `Entity`의 변경이 일어났을 때 이를 감지하고 변경한 내용을 자동으로 `DB`에 반영하는 것을 말한다. ( 이때 변경의 기준은 최초 조회 상태이다. ) `JPA` 에서는 트랜잭션이 끝나는 시점에 변화가 있던 모든 엔티티의 객체를 데이터베이스로 알아서 반영을 시켜준다. 즉, 트랜잭션의 마지막 시점에 다른 점을 발견했을 때 데이터베이스로 `update` 쿼리를 날려준다.

또한, 기본적으로 더티 체킹을 실행하면, `SQL` 에서 변경된 엔티티의 모든 내용을 `update` 쿼리로 만들어 전달하는데, 이때 필드가 많아지면 전체 필드를 `update`하는게 비효율적일 수도 있다. 이때는 `@DynamicUpdate`를 해당 `Entity`에 선언하여 변경 필드만 반영시키도록 만들 수 있다.

더티 체킹을 검사하는 대상은 `영속성 컨텍스트`가 관리하는 `Entity`만 대상으로 한다. 준영속, 비영속 `Entity` 는 값을 변경할지라도 데이터베이스에 반영하지 않는다.

Spring Data JPA 에서는 `@Transactional` 을 사용하여 더티 체킹을 수행할 수 있다.
```

#### 🗨 JPA N+1 이 무엇인지 그리고 해결방법

```
연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 조회하려는 엔티티를 조회하기 위한 쿼리의 개수 ( 1개 ) 와 조회된 엔티티의 개수 ( n개 ) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다. 이를 N+1 문제라고 한다.

해결방법으로는 Fetch Join, EntityGraph, FetchMode.SUBSELECT, BatchSize, QueryBuilder 이 있다.
```

#### 🗨 WS와 WAS에 대해 설명하세요.

```
웹 서버란 HTTP 프로토콜을 기반으로 클라이언트로 부터 요청을 받아 그에 해당하는 정적 콘텐츠를 제공하는 컴퓨터 프로그램 또는 웹 서버가 설치되어 있는 컴퓨터를 말한다. 이때 정적 콘텐츠는 HTML, CSS, 이미지 등 즉시 응답가능한 자원을 말하며 개발자가 변경하지 않는이상 항상 동일하게 유지되는 자원을 말한다.

웹 어플리케이션 서버는 웹 서버와 웹 컨테이너의 기능을 모두 수행하는 프로그램으로 웹 서버가 클라이언트로부터 동적 콘텐츠에 대한 요청을 받을 경우 해당 요청을 전달받아 DB 조회 또는 비즈니스 로직 처리 등의 작업을 수행하여 클라이언트에게 동적 컨텐츠를 제공하는 역할을 한다.
```

#### 🗨 WS와 WAS를 함께 사용하여 얻는 이점

```
- 웹 서버를 통해 정적인 파일들을 `WAS` 까지 가지 않고 앞단에서 빠르게 처리할 수 있다.
- 비즈니스 로직같은 동적인 처리가 필요하면 `WAS`에 위임한다.
- `WAS` 는 기본적으로 애플리케이션 로직을 사용해 동적 페이지를 제공하기 위해 최적화 되어있는 서버이다.
- `Web Server` 와 `Web Application Server` 를 함께 사용하여 효율적인 리소스 처리가 가능해진다. 정적 리소스 요청 증가시 `Web Server` 만 증설할 수 있으며 동적 리소스 요청 증가시 `Web Application Server` 만 증설하여 서버를 안정적으로 관리할 수 있다.
```

#### 🗨 CORS가 무엇인지 그리고 그 해결방법

```
교차 출처 리소스 공유 ( Cross-Origin Resource Sharing, CORS ) 는 웹 애플리케이션에서 서로 다른 도메인에서 리소스를 요청할 때 발생하는 보안 상의 문제를 해결하기 위한 메커니즘 이다. 브라우저에서는 보안적인 이유로 다른 출처의 HTTP 요청을 제한한다. 그래서 다른 출처의 요청을 하려면 서버의 동의가 필요하다. 이때 사용되는 것이 CORS 이다. CORS 는 HTTP 헤더를 사용하여 허용된 도메인에서만 리소스 요청을 허용하는 방식으로 동작한다. 이를 통해, 웹 애플리케이션이 다른 Origin에서 호스팅되어있는 API 나 서비스를 안전하게 사용할 수 있게 됩니다.

`CORS` 를 해결하는 방법으로 크롬 확장 프로그램을 이용하거나 프록시 사이트를 이용하는 방법등이 있으나 서버에서 `Access-Control-Allow-Origin` 헤더를 설정해주는 방법이 가장 정석적인 해결방법이라고 할 수 있다.
```

#### 🗨 쿠키 란?

```
쿠키란 사용자의 웹 브라우저에 저장하는 작은 데이터 기록 파일로 `key-value` 형식의 문자열로 구성된다. 서버는 클라이언트의 사용자 정보를 웹 브라우저에 저장하기 위한 목적으로 쿠키를 사용하는데 이는  `HTTP 프로토콜`은 `비연결` 그리고 `무상태` 특성 때문이다. 이런 특성으로 인해 서버는 클라이언트를 매 연결시 확인해야 하는 비효율적인 상황이 발생한다. 따라서 이 특징을 보완하기 위한 방법중 하나가 쿠키를 사용한다. 클라이언트의 상태 정보를 담은 쿠키를 통해 사용자의 웹 브라우저에 를 저장하면 이후의 요청은 사용자가 별도로 요청하지 않아도 브라우저가 요청시에 `Request Header` 에 담아 자동으로 서버에 전송한다.

쿠키는 사용자 인증이 유효한 시간을 명시할 수 있으며 유효 시간이 정해지면 브라우저가 종료 되어도 클라이언트에 쿠키를 보관하고 있어 인증을 유지할 수 있다는 특징을 가지고 있으며 최대 `4KB`까지 데이터를 저장할 수 있다.
```

#### 🗨 세션이란?

```
세션이란 브라우저에서 웹 서버에 접속한 시점부터 브라우저를 종료하여 연결을 끝내는 시점까지의 기간동안 일련의 요청을 하나의 상태로 간주하고 그 상태를 유지하는 기술을 말한다. 세션은 쿠키를 사용하기는 하지만 사용자 정보를 브라우저에 저장하는 쿠키와 달리 서버측에서 사용자 정보를 관리한다.

클라이언트를 구분하기 위해 `세션ID`를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다. 사용자 정보를 서버에서 보관하기 때문에 쿠키와 비교하여 보안적인 측면에서 강점이 있지만 사용자가 많아질수록 서버 메모리를 많이 차지하게 된다. 이로 인해 서버에 과부하를 주게되어 성능 저하의 요인이 되기도 한다.
```

#### 🗨 쿠키와 세션의 차이

```
- 쿠키와 세션은 사용자 정보의 저장 위치가 다르다. 쿠키는 클라이언트에 사용자 정보를 저장하기 때문에 서버의 자원을 사용하지 않지만 세션은 서버에 사용자 정보를 저장하기 때문에 서버의 자원을 사용한다.

- 사용자 정보의 보관측면에서도 차이가 있다. 쿠키는 만료시간을 설정해 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 세션도 만료시간을 설정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.

- 속도 측면에서는 세션이 쿠키에 비해 빠르다. 그 이유는 쿠키는 클라이언트 로컬환경에 사용자 정보가 저장되기 때문에 서버 요청시에 별도의 처리가 필요하지 않아 속도가 빠르다. 하지만, 세션은 사용자 정보가 저장되어 있기 때문에 서버의 처리가 필요하기 때문에 쿠키에 비해 상대적으로 속도가 느리다.

- 보안 측면에서 세션이 쿠키보다 우수한데 그 이유는 쿠키는 클라이언트 로컬에 저장하기 때문에 데이터가 유출되거나 변질될 우려가 있어 보안에 취약하지만 세션은 쿠키를 이용해서 `세션ID` 만 저장하고 `세션ID` 로 클라이언트를 구분해서 서버에서 처리하기 때문에 비교적 보안이 뛰어나다.
```

#### 🗨 세션과 쿠키중 어떤것을 사용했고 그 이유는?

```
인증과정에서 쿠키를 사용했다. 그 이유는 세션은 서버의 자원을 사용하기 때문에 클라이언트의 증가로 인한 무분별한 세션의 생성은 서버의 메모리에 부담을 주게 되어 서버에 과부하가 걸릴 수 있기 때문이다.
```

#### 🗨 로컬 스토리지와 쿠키 중 어떤것이 더 안전한지 그리고 그 이유는?

```
상황에 따라 다르겠지만 쿠키가 조금 더 안전할 수 있다고 생각한다. 그 이유는

- 쿠키의 `HttpOnly` 속성을 사용하면 쿠키가 공격자가 접근하기 조금 더 어려워진다.
- 쿠키는 CSRF 공격에 취약하지만 `sameSite 플래그`와 `anti-CRSF token` 을 사용하여 어느정도 예방이 가능하다.
- `Authorization: Bearer header`를 사용해야 하거나 `JWT` 크기가 `4KB`보다 큰 경우에도 작동 가능하게 할 수 있다.
```

#### 🗨 JWT 란 무엇인가?

```
JWT 는 인증에 필요한 정보들을 암호화 시킨 JSON 토큰을 의미한다. JWT 는 JSON 데이터를 Base64 URL-safe Encode 를 통해 인코딩하여 직렬화한 것이며, 토큰 내부에는 위변조 방지를 위해 개인키를 통한 전자서명도 들어가 있다. 따라서, 사용자가 JWT 를 서버로 전송하면 서버는 서명을 검증하는 과정을 거치게 되며 검증이 완료되면 요청한 응답을 돌려준다.
```

#### 🗨 토큰 인증이 신뢰성을 가지는 이유

```
토큰을 탈취당하여 토큰내의 데이터가 임의로 조작되어도 서버에서 유효성검사를 통해 토큰의 조작여부를 파악할 수 있다. 서버는 토큰내의 정보가 중요한것이 아니라 해당 토큰이 유효한 토큰인지 확인하는 것이 중요하다. 따라서, 클라이언트로부터 받은 JWT의 헤더, 페이로드를 서버의 key 값을 이용해 시그니처를 다시 만들고 이를 비교하며 일치했을 경우 인증을 통과시킨다.
```

#### 🗨 Spring Security와 인증/인가에 대해 설명하세요.

```
Spring Security 는 스프링 기반 애플리케이션의 보안(인증과 권한)을 담당하는 사용자 인증 및 접근제어 프레임 워크를 말한다. 자바 애플리케이션의 인증 및 권한 부여를 제공하는데 중점을 두고 있으며 다양한 필터를 사용하여 커스텀이 가능하다.

인증: 사용자가 서비스에 접근할 수 권한이 주어진 사용자인지 확인하는 행위
인가: 어떤 대상이 특정 자원에 접근할 수 있는 권한이 있는지 확인하는 과정.
```

#### 🗨 필터와 인터셉터의 차이점

```
- Filter 는 웹 컨테이너에의해 관리되고 Interceptor는 스프링 컨테이너에 의해 관리된다.
- Filter에서 발생하는 예외는 Spring 내 예외처리로 처리가 불가능한 반면 Interceptor는 가능하다.
- 필터의 경우 HttpSevlet request & response 객체를 조작할 수 있지만 Interceptor는 불가능하다.
- 스프링 인터셉터가 조금 더 정교화화된 사용이 가능하다.
```
