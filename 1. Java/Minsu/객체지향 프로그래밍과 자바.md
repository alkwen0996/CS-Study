## 객체지향 프로그래밍과 자바(Java)

---

### 객체지향언어

다수의 객체간 상호작용을 통해 하나의 프로그램이 동작하도록 프로그램을 개발하는 프로그래밍 언어를 객체지향언어라고 한다. 대표적으로 C++, Java 언어 등이 이에 해당한다.

<br>

### 객체

`속성`과 `기능`으로 구성된 객체지향 프로그래밍의 가장 기본적인 단위를 말한다. 기본적으로 우리가 보고 느끼고 생각하는 모든 유/무형의 것들은 객체가 될 수 있다. 이런 객체들을 모아 그들간에 관계를 통해 프로그램을 만드는 방법을 객체지향 프로그래밍이라고 한다.

<br>

### 절차지향프로그래밍

절차지향 프로그래밍은 프로그램의 순서와 흐름을 세우고 필요한 자료구조와 함수들을 설계하는 방식으로 데이터 중심의 함수를 기반으로 프로그램을 작성한다. 컴퓨터의 작업방식과 유사하기 때문에 객체지향언어에 비해 성능적으로 더 뛰어나다. 반면, 유기적으로 연결되어 프로그램이 동작하는 만큼 유지보수가 어렵다는 단점이 있다.

<br>

### 객체지향 프로그래밍(OOP)

`객체지향 프로그래밍(OOP)` 컴퓨터 프로그램을 여러 개의 독립된 단위, 즉 `객체` 들간의 관계를 통해 프로그램을 구성하는 프로그래밍 방법론을 말한다. 각각의 객체는 `메시지`를 주고받는 과정을 통해 `데이터`를 처리할 수 있다. 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 쉽게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 또한, 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점이 있지만 설계가 복잡하기 때문에 개발속도가 느리고 JVM에서 기계어로 번역되는 과정을 거치기 때문에 실행 속도가 느리다는 단점이 있습니다. 이런 객체지향 프로그래밍의 특징으로는 `추상화`, `캡슐화`, `상속`, `다형성` 이 있다.

<br>

### 객체지향 프로그래밍(OOP)의 특징

- 상속
- 캡슐화
- 추상화
- 다형성

<br>

**[상속]**

기존 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는것을 의미한다. 상속은 하위클래스가 상속받는 상위 클래스의 개수에 따라 단일 상속과 다중 상속으로 구분하지만 자바는 다중 상속을 지원하지 않는다. 상속을 받은 하위 클래스는 상위 클래스의 특성과 기능을 재정의 하여 사용할 수 있으며 이는 코드의 중복을 제거하고 재사용을 용이하게 한다는 장점이 있습니다. <br><br>
상속은 `extends`키워드를 통해 이루어진다.
단, 부모 클래스의 `접근제어자`가 `private` 인 속성이나 메서드는 상속이 불가능하다. 또한, `final` 이 붙은 메서드와 클래스역시 상속이 불가능하다.

<br>

**[캡슐화]**

객체의 데이터와 메서드를 하나로 묶어서 외부의 다른 객체들로부터 객체 내부의 구현을 감추고 사용법만 제공하는 것을 말한다. 객체 외부에서는 객체 내부정보에 직접 접근하거나 조작할 수 없고 외부에서 접근할 수 있도록 정의된 `getter/setter` 등을 통해서만 관련 데이터에 접근할 수 있다. 캡슐화된 객체들은 외부로부터 독립적이기 때문에 변경으로 인한 오류의 가능성이 감소하고 인터페이스가 단순해지며 객체간 결합도가 낮아진다는 장점이 있다. <br><br>
자바언어에서 `캡슐화`를 구현하는 방법에는 `접근제어자`를 활용하는 방법과 `getter/setter` 를 활용하는 방법이 있다.

<br>

**[추상화]**

객체의 불필요한 세부사항을 배제하고 본질적이고 중요한 정보만을 나타내기 위해 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 말한다. 역할과 구현을 분리하여 객체가 가진 속성중 필수 속성 만으로 객체를 표현하고 세부적인 사항은 각 객체에 따라 다르게 구현되도록 하는 프로그램 설계 방법으로 유연하고 변경에 용이한 프로그램을 만드는데 핵심적인 부분이다. <br><br>
자바언어에서 추상화를 구현하는 방법에는 `추상클래스`와 `인터페이스`가 있다.

<br>

```java
public interface Vehicle{
	void moveForward();
}

class Car implements Vehicle{
	@Override
	public void moveForward(){
		System.out.println("자동차가 앞으로 움직입니다.");
	}
}

class Motobike implements Vehicle{
	@Override
	public void moveForward(){
		System.out.println("오토바이가 앞으로 움직입니다.");
	}
}
```

<br>

**[다형성]**

`다형성`이란 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것을 의미합니다. 좀 더 구체적으로, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것입니다. 다형성을 활용하면 **하나의 타입으로 여러 가지 타입의 객체를 참조**할 수 있어 보다 간편하고 유연하게 코드를 작성하는 것이 가능해진다. <br><br>

> 다형성의 대표적인 방법으로 `메서드 오버라이드`과 `메서드 오버로딩`이 있다.

<br>

```java
public interface Vehicle{
	void moveForward();
}

class Car implements Vehicle{
	@Override
	public void moveForward(){
		System.out.println("자동차가 앞으로 움직입니다.");
	}
}

public class Main{
	public static void main(String[] agrs){
		// 일반적인 객체생성방식
		Car car = new Car();

		// 다형성을 사용한 객체생성방식
		Vehicle car2 = new Vehicle();
	}
}

/*
상위클래스 타입의 참조변수로 하위클래스 객체를 참조하는 것 의 의미를 조금 더 구체적으로 이해할 수 있습니다.
원래 우리가 사용했던 방식은 하위 클래스의 객체를 생성하여 하위 클래스 타입의 참조 변수에 할당해주었지만,
다형성을 활용한 방식에서는 하위 클래스의 객체를 생성하여 상위 클래스 타입의 참조변수 car2 에 할당해주고 있습니다.
*/
```

<br>

### Java언어의 특징

- 객체단위로 프로그램을 작성하기 때문에 절차지향언어에 비해 유지보수가 쉽고 확장성이 높다.
- JVM위에서 동작해서 운영체제의 종류에 영향을 받지 않아 이식성이 높다.
- 가비지 컬렉션을 통해 메모리를 자동으로 관리해준다.
- 스레드 생성 및 제어와 관련된 라이브러리를 제공하기 때문에 멀티 스레드 구현이 쉽다.
- 실행시 모든 클래스를 로딩하지 않고 필요한 시점에 클래스를 로딩하는 동적 로딩을 지원한다.

<br>

### Java언어를 사용하는 이유

Java는 객체지향 프로그래밍을 가장 대중적이고 편하게 구현할 수 있는 언어라고 생각하며, 많은 엔터프라이즈급 회사에서 오랜 기간 사용된 만큼 안정성이 보장된 언어라고 생각한다. 또한 자바 진영은 하위 호환성을 중요하게 여기는 점과 레퍼런스와 커뮤니티가 활성화 되어있는 점이 매력적으로 다가왔다. 이러한 이유로 Java 언어를 사용하여 개발하고 있다.

<br>

### 객체지향 설계 5원칙(SOLID)

좋은 객체 지향 프로그래밍 및 설계를 위한 5가지 원칙을 말한다. 이 SOLID 원칙을 통해 코드를 확장하고 유지보수 관리하기가 쉬워지며 불필요한 복잡성을 제거해 리팩토링에 소요되는 시간을 줄여 개발의 생산성을 높일 수 있다.

- 단일책임 원칙(SRP)
- 개방-폐쇄 원칙(OCP)
- 리스코프 치환 원칙(LSP)
- 인터페이스 분리 원칙(ISP)
- 의존관계 역전 원칙(DIP)

<br>

**[단일책임 원칙(SRP) → "객체는 오직 하나의 책임을 가져야 한다"]**

클래스는 단 하나의 역할(책임)만 가져야 하며 클래스는 그 책임을 완전히 캡슐화해야 한다는 것을 의미한다. 즉, 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하는데 집중할 수 있도록 클래스를 설계하라는 원칙으로 이를 통해 불필요한 책임의 변경으로 인한 연쇄작용을 극복할 수 있게 되어 프로그램의 유지보수성을 높일 수 있다.

<br>

**[개방-폐쇄 원칙 → "객체는 확장에 대해선 개방적이고, 수정에 대해선 폐쇄적이어야 한다"]**

클래스나 메서드 등 소프트웨어의 요소는 확장에는 열려있으나 수정(변경)에는 닫혀 있어야 하는 것을 의미한다. 기능 추가에 따라 클래스는 손쉽게 확장하면서 확장에 따른 클래스의 수정은 최소화하도록 프로그램을 작성해야 하는 설계 기법으로 다형성과 확장을 가능하게 하는 객체지향의 장점을 최대화하는 원칙이다.

```java
public class MemberService {

//private final MemberRepository memberRepository = new MemoryMemberRepository();
// 기존 코드

private final MemberRepository memberRepository = new JdbcTemplateMemberRepository();
// 변경 코드
...

//구현 객체를 변경하기 위해서는 클라이언트인 MemberService의 코드를 수정해야 한다.
//OCP의 원칙을 지키지 못하고 있다.
```

<br>

**[리스코프 치환 원칙(LSP) → "상위 클래스는 언제나 하위 클래스를 대체할 수 있다"]**

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 클래스로 변경해도 정상적으로 동작해야 함을 의미한다. 이는 하위 타입은 언제나 상위 타입으로 교체할 수 있어야 한다는 것을 말하며 다형성의 원리를 이용하기 위한 원칙이다. 이를 지키지 못할 경우 `is-a` 관계가 망가져 다형성을 사용할 수 없게 된다. 따라서, 하위 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야한다.

```java
public void myData() {
	// Collection 인터페이스 타입으로 변수 선언
    Collection data = new LinkedList();
    data = new HashSet(); // 중간에 전혀 다른 자료형 클래스를 할당해도 호환됨

    modify(data); // 메소드 실행
}

public void modify(Collection data){
    list.add(1); // 인터페이스 구현 구조가 잘 잡혀있기 때문에 add 메소드 동작이 각기 자료형에 맞게 보장됨
    // ...
}
```

<br>

> **`is-a` 관계** <br>
> 추상화된 클래스 사이의 상속관계를 의미한다.
> ex) A 클래스: 동물 / B 클래스 : 포유류, 파충류

<br>

> **`has-a` 관계** <br>
> 한 객체가 다른 객체에 속하는 포함관계임을 이야기한다.
> \*\*\*\*ex) A 클래스 : 차 / B 클래스 : 엔진

<br>

**[인터페이스 분리 원칙(ISP) → "클라이언트에서 사용하지 않는 인터페이스에 의존하지 않아야 한다"]**

특정 클라이언트를 위한 범용 인터페이스 하나보다 구체적인 인터페이스 여러 개를 사용하도록 하는 의미의 설계 원칙으로 인터페이스의 단일 책임 원칙을 강조한다. 즉, 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 하며 인터페이스는 클라이언트가 필요한 기능만 제공해야 한다.

```java
예를 들어, 자동차 인터페이스가 있다고 가정해보자.

자동차 인터페이스 -> 운전, 정비 인터페이스로 각각 분리한다.
사용자 인터페이스 -> 운전자, 정비사 클라이언트로 각각 분리한다.

이렇게 인터페이스를 분리함으로써 정비 인터페이스가 변해도 운전자 클라이언트에 영향을 주지 않는다.

인터페이스가 명확해지고 쉽게 대체할 수 있다.
```

<br>

**[의존관계 역전 원칙(DIP) → "추상성이 높은 고수준의 클래스는 구체적인 저수준의 클래스에 의존해선 안 된다"]**

특정 클래스를 참조해야하는 상황이 생긴다면 해당 클래스를 참조하는 것이 아니라 그 대상의 상위 요소(추상클래스 또는 인터페이스)를 참조하도록 하는 것을 말한다. 다시 말해 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다 변화하기 어려운(거의 변화가 없는) 것에 의존한다는 원칙이다. 구체적인 클래스보단 인터페이스나 추상 클래스와 관계를 맺는 것이 좋다. 이 원칙의 핵심은 각 클래스간의 결합도를 낮추는데 있다. 변화가 적은 것에 의존해 코드의 수정을 최대한 지양하도록 하는 설계 원칙이다.

<br>

> **고수준 클래스** <br>
> 추상성이 높고 안정적인 모듈로 시스템의 핵심 비즈니스 로직이나 기능을 구현하는 클래스를 말한다. 구체적인 세부 사항에 직접적으로 의존하지 않아야 하며 추상화된 인터페이스나 추상 클래스에 의존해야 한다.

<br>

> **저수준 클래스** <br>
> 구체적이고 안정성이 떨어지는 모듈로 시스템의 세부 구현을 담당한다. 데이터베이스 액세스나 파일 입출력 등과 같은 세부사항을 처리한다. 이 클래스는 고수준 클래스의 요구 사항에 따라 구체적인 방식으로 동작한다.

<br><br>

## Java8 & Java11 버전 정리

---

### 자바8 버전 특징

**[인터페이스에서 `default메서드` `static메서드` ]**

**인터페이스에서 `default메서드` `static메서드` 를 사용**할 수 있게 되었다. `default메서드` 는 하위 클래스에서 재 정의가 가능하지만, `static메서드` 는 구현 클래스에서 재 정의할 수 없다.

**[함수형 인터페이스]**

**[람다식 표현식]**

**[스트림 API]**

**[메서드 참조]**

**[배열 정렬의 병렬 처리]**

**[`Date and Time API` 지원]**

**[`Optional` 지원]**

**[Java 8의 Default GC는 Paralle GC]**

<br>

### 자바11 버전 특징

**[`String 클래스` 에 새로운 메서드 추가]**

`strip()`, `stripLeading()`, `stripTrailing()`, `isBlanck()`, `repeat()`

**[`java.nio.file.Files` 클래스에 새로운 메서드 추가 ]**

`writeString()` , `readString()` , `isSameFile()`

**[컬렉션 인터페이스에 새로운 메서드 추가]**

**[Predicate 인터페이스에 새로운 메서드 추가]**

**[람다에서 로컬변수 `var` 사용]**

**[`javac` 로 컴파일 하지 않고도 `java` 사용 파일을 실행할 수 있게 되었다.]**

**[11버전 부터는 Oracle JDK가 아닌 Open JDK를 무료로 사용할 수 있다.]**

**[ G1 GC가 기본 GC로 설정 (GC : Garbage Collection)]**

<br>

> **LTS 버전**
> Long Term Support의 줄임말로 오랜 기간 지원하는 특별한 버전의 에디션이다. LTS 버전으로는 `8`, `11`, `17` 버전이 있다.

<br>

### Java 버전을 선택하는 기준

많은 기업에서 자바8버전을 사용하고 있는것으로 알고 있다. 이는 그만큼 자바8버전이 안정적이고 개발시 필요한 대부분의 기능을 제공한다고 생각한다. 또한, 자바 11버전에서도 메서드와 기능들이 추가되었지만 실질적으로 개발시 많이 사용하는 기능들은 8버전과 크게 차이가 나지 않았다. 따라서 만약, 8버전에 대한 릴리즈를 지원하지 않을때 버전을 변경해도 문제가 생기지 않을거라고 생각해 8버전을 사용했다.

<br><br>

## JRE & JDK

---

### JRE(Java Runtime Environment)

자바 실행 환경이다. `JRE`는 `JVM` 및 `JAVA` 클래스 라이브러리 등을 포함하고 있어 자바 프로그램의 실행을 지원한다. 하지만 컴파일러나 디버거 등의 도구는 포함하지 않는다. 따라서 자바 프로그램을 개발하는 것이 아닌 실행하기만 원한다면 `JRE`를 설치하면 된다.

<br>

### JDK(Java Development Kit)

자바 개발 키트를 말한다. 자바 애플리케이션을 개발하기 위한 환경을 지원한다. `JDK`는 `**JRE**`를 포함할 뿐만 아니라 컴파일러(`javac`**),** `jar`등 개발에 유용한 도구들을 포함하고 있다. 따라서 자바 프로그램을 개발하기 위해서는 `JDK` 를 사용하면 된다.

즉, `JRE` 는 자바 실행 환경을 말하고 `JDK` 자바 개발 도구를 말한다.

<br><br>

## Java SE & Java EE

---

### 자바 프로그래밍 언어 플랫폼

모든 자바 플랫폼들은 `JVM`(자바가상머신)과 `API`(어플리케이션 프로그래밍 인터페이스)로 구성되어 있다. 각각의 자바 플랫폼에서는 `JVM` 과 `API` 를 제공함으로써 해당 플랫폼에서 작성된 애플리케이션이 자바 프로그래밍언어의 장점(플랫폼에 비종속적, 안정성 등)을 그대로 갖출 수 있도록 한다.

자바 언어 플랫폼의 종류로는 `Java SE`, `Java EE`, `Java ME`, `Java FX`등이 있다.

<br>

### Java SE (표준 에디션 자바 플랫폼)

가장 기본이 되는 표준 에디션인 자바 플랫폼으로 `Java SE`의 `API`는 자바 프로그래밍 언어의 핵심 기능을 제공한다. 보통 JavaSE Development Kit, 줄여서 `JDK`를 설치 받아서 사용할 수 있다. `java.lang.*` , `java.io.*` , `java.util.*` , `java.awt.*` 등등 자바 기술을 사용하는 애플리케이션에서 일반적으로 사용하는 대부분의 패키지가 이에 속한다. Java 프로그래밍 언어의 기본 유형 및 개체에서 네트워킹, 보안, 데이터베이스 액세스, 그래픽 사용자 인터페이스(GUI) 개발 및 XML 구문 분석에 사용되는 고급 클래스에 이르기까지 모든 것을 정의한다. 따라서 JDBC와 GUI, 네트워크 등 각종 API를 이용해서 개발이 가능합니다.

<br>

### Java EE (엔터프라이즈 에디션 자바 플랫폼)

Java EE 플랫폼은 Java SE 플랫폼 위에 구축됩니다. `Java EE` 플랫폼은 대규모, 다계층, 확장 가능하고 안정적이며 안전한 네트워크 애플리케이션을 개발하고 실행하기 위한 API 및 런타임 환경을 제공합니다. WEB 개발에 필요한 기능을 다수 포함하고 있어 WEB 프로그래밍시 `Java EE`로 개발을 진행한다. 대표적으로 JSP, Servlet과 JSON, REST 반응형 클라이언트 API, 웹소켓 등을 지원한다.

<br>

### Java ME(마이크로 에디션 자바 플랫폼)

모바일 폰과 같은 자바 프로그래밍 언어 기반의 애플리케이션이 보다 작은 가상 머신으로 동작시킬 수 있는 기능과 API를 제공하는 플랫폼으로 `Java SE` 를 기반으로 한다. 작은 장치에서 동작하는 전용 클래스 라이브러리를 제공하며 `Java EE` 서비스의 클라이언트 역할을 하기도 한다.

<br><br>

### [Reference]

[☕ 인터페이스 vs 추상클래스 용도 차이점 - 완벽 이해](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

[[Java] Java는 Call by reference가 없다](https://deveric.tistory.com/92)

[Java 의 Call by Value, Call by Reference](https://bcp0109.tistory.com/360)

[[Java] Call by Value, Call by Reference](https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference)
